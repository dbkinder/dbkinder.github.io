

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en" > <!--<![endif]-->
  <head>
    <meta charset="utf-8">
   <!-- Google Tag Manager -->
   <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
   new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
   })(window,document,'script','dataLayer','GTM-KMP8MS');</script>
   <!-- End Google Tag Manager -->
    <link rel="apple-touch-icon" sizes="57x57" href="../../_static/img/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../../_static/img/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../../_static/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../../_static/img/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../../_static/img/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../../_static/img/apple-touch-icon-120x120.png">
    <link rel="icon" type="image/png" href="../../_static/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../_static/img/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="../../_static/img/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="../../_static/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Zephyr Project">
    <meta name="application-name" content="Zephyr Project">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    
    <title>System Calls &mdash; Zephyr Project Documentation</title>
    

    
    

    

    
    
      
    

    
    
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    

    
      <link rel="stylesheet" href="../../_static/zephyr-custom.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/normalize.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/layout.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/main.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    

    
        <link rel="index" title="Index" href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
        <link rel="copyright" title="Copyright" href="../../copyright.html"/>
      <link rel="top" title="Zephyr Project Documentation" href="../../index.html"/>
        <link rel="up" title="User Mode" href="usermode.html"/>
        <link rel="next" title="Memory Domain" href="memory_domain.html"/>
        <link rel="prev" title="Kernel Objects" href="kernelobjects.html"/> 

    
    <script src="../../_static/js/modernizr.min.js"></script>

  </head>

  <body class="not-front page-documentation one-sidebar sidebar-first" role="document" >
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KMP8MS"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="page">
      <header id="header">
  <div class="header-wrapper">
    <div class="container">
      <a href="https://zephyrproject.org/" title="Zephyr Project" rel="home" id="logo">
        <img src="../../_static/img/logo_white.png" alt="Zephyr Project">
      </a>
      <a href="" id="navigation-toggle">
        <span> </span>
        Menu
      </a>
      <nav id="navigation" class="menu with-primary with-secondary">
        <ul class="header-menu main-menu">
          <li class="first expanded about mid-1209"><a href="https://zephyrproject.org/about/"><span>About</span></a>
            <ul class="menu">
              <li class="first leaf what-is-zephyr mid-2563"><a href="https://zephyrproject.org/what-is-zephyr/"><span>What is the Zephyr Project?</span></a></li>
              <li class="leaf organization mid-2564"><a href="https://zephyrproject.org/about/organization/"><span>Organization</span></a></li>
              <li class="leaf memberships mid-2532"><a href="https://zephyrproject.org/#members"><span>Members</span></a></li>
              <li class="leaf faq mid-2525"><a href="https://zephyrproject.org/about/#faq"><span>FAQ</span></a></li>
              <li class="leaf join mid-2622"><a href="https://zephyrproject.org/join/"><span>Join</span></a></li>
              <li class="last leaf contact-us mid-2530"><a href="https://zephyrproject.org/about/#contact-us"><span>Contact Us</span></a></li>
            </ul>
          </li>
          <li class="expanded developers mid-1209"><a href="https://zephyrproject.org/developers/"><span>Developers</span></a>
            <ul class="menu">
              <li class="first expanded leaf code mid-2563"><a href="https://github.com/zephyrproject-rtos/zephyr/" target="_blank"><span>Code</span></a></li>
              <li class="leaf downloads mid-2564"><a href="https://zephyrproject.org/developers/#downloads"><span>Downloads</span></a></li>
              <li class="leaf documentation mid-2564"><a href="http://docs.zephyrproject.org/index.html" target="_blank"><span>Documentation</span></a></li>
              <li class="leaf supported-boards mid-2564"><a href="http://docs.zephyrproject.org/boards/boards.html" target="_blank"><span>Supported Boards</span></a></li>
              <li class="leaf releases-overview mid-2564"><a href="https://zephyrproject.org/developers/#releases-overview"><span>Releases Overview</span></a></li>
              <li class="leaf how-to-contribute mid-2564"><a href="https://zephyrproject.org/developers/how-to-contribute/"><span>How to Contribute</span></a></li>
              <li class="last leaf community-guidelines mid-2564"><a href="https://zephyrproject.org/developers/how-to-contribute/#community-guidelines"><span>Community Guidelines</span></a></li>
            </ul>
          </li>
          <li class="expanded news mid-1209"><a href="https://zephyrproject.org/news/"><span>News</span></a>
            <ul class="menu">
              <li class="first leaf announcements mid-2563"><a href="https://zephyrproject.org/news/announcements/"><span>Announcements</span></a></li>
              <li class="leaf blog mid-2563"><a href="https://zephyrproject.org/news/blog/"><span>Blog</span></a></li>
              <li class="last leaf events mid-2563"><a href="https://zephyrproject.org/events/"><span>Events</span></a></li>
            </ul>
          </li>
          <li class="last expanded project-resources mid-1209"><a href="https://zephyrproject.org/project-resources/"><span>Project Resources</span></a>
            <ul class="menu">
              <li class="first leaf presentations mid-2563"><a href="https://zephyrproject.org/project-resources/presentations/"><span>Presentations</span></a></li>
              <li class="leaf videos mid-2563"><a href="https://zephyrproject.org/project-resources/videos/"><span>Videos</span></a></li>
              <li class="leaf demos mid-2563"><a href="https://zephyrproject.org/project-resources/demos/"><span>Demos</span></a></li>
              <li class="leaf zephyr-in-market mid-2563"><a href="https://zephyrproject.org/project-resources/zephyr-in-market/"><span>Zephyr in Market</span></a></li>
              <li class="last leaf developer-tools mid-2563"><a href="https://zephyrproject.org/project-resources/developer-tools/"><span>Developer Tools</span></a></li>
            </ul>
          </li>
        </ul>
      </nav><!-- /navigation -->
    </div>
  </div>
</header><!-- /header -->
      <!-- STARTS #main -->
      <div id="main">
        <!-- STARTS .main-container -->
        <div class="main-container">
          

 



<!-- Docs -->





<div id="breadcrumb">
  <div class="container">
    <a href="/">Home</a> / 
    <a href="../../index.html">Docs</a> /
      
          <a href="../kernel.html">Zephyr Kernel Primer</a> /
      
          <a href="usermode.html">User Mode</a> /
      
  </div>
</div>
          <aside id="sidebar-first" class="container-sidebar">
            
            <span id="secondary-menu-button" class="">Documentation</span>
<div class="region region-sidebar">
  <div class="docs-menu">
  
    
    
        <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/introducing_zephyr.html">Introducing Zephyr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/getting_started.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/contribute.html">Contributing to the Zephyr Project</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../kernel.html">Zephyr Kernel Primer</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../overview/overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../threads/threads.html">Threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../timing/timing.html">Timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory/memory.html">Memory Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../synchronization/synchronization.html">Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_passing/data_passing.html">Data Passing</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="usermode.html">User Mode</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernelobjects.html">Kernel Objects</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">System Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory_domain.html">Memory Domain</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../other/other.html">Other Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../security/security.html">Zephyr Project Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../application/index.html">Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/boards.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devices/index.html">Device and Driver Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystems/subsystems.html">Subsystems</a></li>
</ul>

    
  
  </div>
<div role="search" class="sphinx-search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search documentation" class="search-documentation" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
</div>
          </aside>
          <!-- STARTS .content SECTION-->
          <section id="content" class="row">
            
	    
            <div class="rst-content">
              <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
                <div itemprop="articleBody">
                  
  <div class="section" id="system-calls">
<span id="syscalls"></span><h1>System Calls<a class="headerlink" href="#system-calls" title="Permalink to this headline">¶</a></h1>
<p>User threads run with a reduced set of privileges than supervisor threads:
certain CPU instructions may not be used, and they have access to only a
limited part of the memory map. System calls (may) allow user threads to
perform operations not directly available to them.</p>
<p>When defining system calls, it is very important to ensure that access to the
API’s private data is done exclusively through system call interfaces.
Private kernel data should never be made available to user mode threads
directly. For example, the <code class="docutils literal"><span class="pre">k_queue</span></code> APIs were intentionally not made
available as they store bookkeeping information about the queue directly
in the queue buffers which are visible from user mode.</p>
<p>APIs that allow the user to register callback functions that run in
supervisor mode should never be exposed as system calls. Reserve these
for supervisor-mode access only.</p>
<p>This section describes how to declare new system calls and discusses a few
implementation details relevant to them.</p>
<div class="section" id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h2>
<p>All system calls have the following components:</p>
<ul class="simple">
<li>A <strong>C prototype</strong> for the API, declared in some header under <code class="docutils literal"><span class="pre">include/</span></code> and
prefixed with <code class="xref c c-macro docutils literal"><span class="pre">__syscall</span></code>.  This prototype is never implemented
manually, instead it gets created by the <code class="docutils literal"><span class="pre">scripts/gen_syscalls.py</span></code> script.
What gets generated is an inline function which either calls the
implementation function directly (if called from supervisor mode) or goes
through privilege elevation and validation steps (if called from user
mode).</li>
<li>An <strong>implementation function</strong>, which is the real implementation of the
system call. The implementation function may assume that all parameters
passed in have been validated if it was invoked from user mode.</li>
<li>A <strong>handler function</strong>, which wraps the implementation function and does
validation of all the arguments passed in.</li>
</ul>
</div>
<div class="section" id="c-prototype">
<h2>C Prototype<a class="headerlink" href="#c-prototype" title="Permalink to this headline">¶</a></h2>
<p>The C prototype represents how the API is invoked from either user or
supervisor mode. For example, to initialize a semaphore:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">__syscall</span> <span class="kt">void</span> <span class="nf">k_sem_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_sem</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">initial_count</span><span class="p">,</span>
                          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="xref c c-macro docutils literal"><span class="pre">__syscall</span></code> attribute is very special. To the C compiler, it
simply expands to ‘static inline’. However to the post-build
<code class="docutils literal"><span class="pre">parse_syscalls.py</span></code> script, it indicates that this API is a system call.
The <code class="docutils literal"><span class="pre">parse_syscalls.py</span></code> script does some parsing of the function prototype,
to determine the data types of its return value and arguments, and has some
limitations:</p>
<ul class="simple">
<li>Array arguments must be passed in as pointers, not arrays. For example,
<code class="docutils literal"><span class="pre">int</span> <span class="pre">foo[]</span></code> or <code class="docutils literal"><span class="pre">int</span> <span class="pre">foo[12]</span></code> is not allowed, but should instead be
expressed as <code class="docutils literal"><span class="pre">int</span> <span class="pre">*foo</span></code>.</li>
<li>Function pointers horribly confuse the limited parser. The workaround is
to typedef them first, and then express in the argument list in terms
of that typedef.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">__syscall</span></code> must be the first thing in the prototype.</li>
</ul>
<p>The preprocessor is intentionally not used when determining the set of
system calls to generate. However, any generated system calls that don’t
actually have a handler function defined (because the related feature is not
enabled in the kernel configuration) will instead point to a special handler
for unimplemented system calls. Data type definitions for APIs should not
have conditional visibility to the compiler.</p>
<p>Any header file that declares system calls must include a special generated
header at the very bottom of the header file. This header follows the
naming convention <code class="docutils literal"><span class="pre">syscalls/&lt;name</span> <span class="pre">of</span> <span class="pre">header</span> <span class="pre">file&gt;</span></code>. For example, at the
bottom of <code class="docutils literal"><span class="pre">include/sensor.h</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;syscalls/sensor.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<div class="section" id="invocation-context">
<h3>Invocation Context<a class="headerlink" href="#invocation-context" title="Permalink to this headline">¶</a></h3>
<p>Source code that uses system call APIs can be made more efficient if it is
known that all the code inside a particular C file runs exclusively in
user mode, or exclusively in supervisor mode. The system will look for
the definition of macros <code class="xref c c-macro docutils literal"><span class="pre">__ZEPHYR_SUPERVISOR__</span></code> or
<code class="xref c c-macro docutils literal"><span class="pre">__ZEPHYR_USER__</span></code>, typically these will be added to the compiler
flags in the build system for the related files.</p>
<ul class="simple">
<li>If <a class="reference internal" href="../../reference/kconfig/CONFIG_USERSPACE.html#cmdoption-arg-config-userspace"><code class="xref std std-option docutils literal"><span class="pre">CONFIG_USERSPACE</span></code></a> is not enabled, all APIs just directly call
the implementation function.</li>
<li>Otherwise, the default case is to make a runtime check to see if the
processor is currently running in user mode, and either make the system call
or directly call the implementation function as appropriate.</li>
<li>If <code class="xref c c-macro docutils literal"><span class="pre">__ZEPHYR_SUPERVISOR__</span></code> is defined, then it is assumed that
all the code runs in supervisor mode and all APIs just directly call the
implementation function. If the code was actually running in user mode,
there will be a CPU exception as soon as it tries to do something it isn’t
allowed to do.</li>
<li>If <code class="xref c c-macro docutils literal"><span class="pre">__ZEPHYR_USER__</span></code> is defined, then it is assumed that all the
code runs in user mode and system calls are unconditionally made.</li>
</ul>
</div>
<div class="section" id="implementation-details">
<h3>Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p>Declaring an API with <code class="xref c c-macro docutils literal"><span class="pre">__syscall</span></code> causes some code to be generated in
C and header files by <code class="docutils literal"><span class="pre">scripts/gen_syscalls.py</span></code>, all of which can be found in
the project out directory under <code class="docutils literal"><span class="pre">include/generated/</span></code>:</p>
<ul class="simple">
<li>The system call is added to the enumerated type of system call IDs,
which is expressed in <code class="docutils literal"><span class="pre">include/generated/syscall_list.h</span></code>. It is the name
of the API in uppercase, prefixed with <code class="docutils literal"><span class="pre">K_SYSCALL_</span></code>.</li>
<li>A prototype for the handler function is also created in
<code class="docutils literal"><span class="pre">include/generated/syscall_list.h</span></code></li>
<li>An entry for the system call is created in the dispatch table
<code class="docutils literal"><span class="pre">_k_sycall_table</span></code>, expressed in <code class="docutils literal"><span class="pre">include/generated/syscall_dispatch.c</span></code></li>
<li>A weak handler function is declared, which is just an alias of the
‘unimplemented system call’ handler. This is necessary since the real
handler function may or may not be built depending on the kernel
configuration. For example, if a user thread makes a sensor subsystem
API call, but the sensor subsystem is not enabled, the weak handler
will be invoked instead.</li>
</ul>
<p>The body of the API is created in the generated system header. Using the
example of <code class="xref c c-func docutils literal"><span class="pre">k_sem_init()</span></code>, this API is declared in
<code class="docutils literal"><span class="pre">include/kernel.h</span></code>. At the bottom of <code class="docutils literal"><span class="pre">include/kernel.h</span></code> is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;syscalls/kernel.h&gt;</span>
</pre></div>
</div>
<p>Inside this header is the body of <code class="xref c c-func docutils literal"><span class="pre">k_sem_init()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">K_SYSCALL_DECLARE3_VOID</span><span class="p">(</span><span class="n">K_SYSCALL_K_SEM_INIT</span><span class="p">,</span> <span class="n">k_sem_init</span><span class="p">,</span> <span class="n">struct</span> <span class="n">k_sem</span> <span class="o">*</span><span class="p">,</span>
                        <span class="n">sem</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span><span class="p">,</span> <span class="n">initial_count</span><span class="p">,</span>
                        <span class="n">unsigned</span> <span class="nb">int</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
</pre></div>
</div>
<p>This generates an inline function that takes three arguments with void
return value. Depending on context it will either directly call the
implementation function or go through a system call elevation. A
prototype for the implementation function is also automatically generated.
In this example, the implementation of the <code class="xref c c-macro docutils literal"><span class="pre">K_SYSCALL_DECLARE3_VOID()</span></code>
macro will be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#if !defined(CONFIG_USERSPACE) || defined(__ZEPHYR_SUPERVISOR__)</span>

<span class="c1">#define K_SYSCALL_DECLARE3_VOID(id, name, t0, p0, t1, p1, t2, p2) \</span>
        <span class="n">extern</span> <span class="n">void</span> <span class="n">_impl_</span><span class="c1">##name(t0 p0, t1 p1, t2 p2); \</span>
        <span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">name</span><span class="p">(</span><span class="n">t0</span> <span class="n">p0</span><span class="p">,</span> <span class="n">t1</span> <span class="n">p1</span><span class="p">,</span> <span class="n">t2</span> <span class="n">p2</span><span class="p">)</span> \
        <span class="p">{</span> \
                <span class="n">_impl_</span><span class="c1">##name(p0, p1, p2); \</span>
        <span class="p">}</span>

<span class="c1">#elif defined(__ZEPHYR_USER__)</span>
<span class="c1">#define K_SYSCALL_DECLARE3_VOID(id, name, t0, p0, t1, p1, t2, p2) \</span>
        <span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">name</span><span class="p">(</span><span class="n">t0</span> <span class="n">p0</span><span class="p">,</span> <span class="n">t1</span> <span class="n">p1</span><span class="p">,</span> <span class="n">t2</span> <span class="n">p2</span><span class="p">)</span> \
        <span class="p">{</span> \
                <span class="n">_arch_syscall_invoke3</span><span class="p">((</span><span class="n">u32_t</span><span class="p">)</span><span class="n">p0</span><span class="p">,</span> <span class="p">(</span><span class="n">u32_t</span><span class="p">)</span><span class="n">p1</span><span class="p">,</span> <span class="p">(</span><span class="n">u32_t</span><span class="p">)</span><span class="n">p2</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span> \
        <span class="p">}</span>

<span class="c1">#else /* mixed kernel/user macros */</span>
<span class="c1">#define K_SYSCALL_DECLARE3_VOID(id, name, t0, p0, t1, p1, t2, p2) \</span>
        <span class="n">extern</span> <span class="n">void</span> <span class="n">_impl_</span><span class="c1">##name(t0 p0, t1 p1, t2 p2); \</span>
        <span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">name</span><span class="p">(</span><span class="n">t0</span> <span class="n">p0</span><span class="p">,</span> <span class="n">t1</span> <span class="n">p1</span><span class="p">,</span> <span class="n">t2</span> <span class="n">p2</span><span class="p">)</span> \
        <span class="p">{</span> \
                <span class="k">if</span> <span class="p">(</span><span class="n">_is_user_context</span><span class="p">())</span> <span class="p">{</span> \
                        <span class="n">_arch_syscall_invoke3</span><span class="p">((</span><span class="n">u32_t</span><span class="p">)</span><span class="n">p0</span><span class="p">,</span> <span class="p">(</span><span class="n">u32_t</span><span class="p">)</span><span class="n">p1</span><span class="p">,</span> <span class="p">(</span><span class="n">u32_t</span><span class="p">)</span><span class="n">p2</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span> \
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> \
                        <span class="n">compiler_barrier</span><span class="p">();</span> \
                        <span class="n">_impl_</span><span class="c1">##name(p0, p1, p2); \</span>
                <span class="p">}</span> \
        <span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>The header containing <code class="xref c c-macro docutils literal"><span class="pre">K_SYSCALL_DECLARE3_VOID()</span></code> is itself
generated due to its repetitive nature and can be found in
<code class="docutils literal"><span class="pre">include/generated/syscall_macros.h</span></code>. It is created by
<code class="docutils literal"><span class="pre">scripts/gen_syscall_header.py</span></code>.</p>
<p>The final layer is the invocation of the system call itself. All architectures
implementing system calls must implement the seven inline functions
<code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke0()</span></code> through <code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke6()</span></code>.  These
functions marshal arguments into designated CPU registers and perform the
necessary privilege elevation. In this layer, all arguments are treated as an
unsigned 32-bit type. There is always a 32-bit unsigned return value, which
may or may not be used.</p>
<p>Some system calls may have more than six arguments. The number of arguments
passed via registers is fixed at six for all architectures. Additional
arguments will need to be passed in a struct, which needs to be treated as
untrusted memory in the handler function. This is done by the derived
functions <code class="xref c c-func docutils literal"><span class="pre">_syscall_invoke7()</span></code> through <code class="xref c c-func docutils literal"><span class="pre">_syscall_invoke10()</span></code>.</p>
<p>Some system calls may return a value that will not fit in a 32-bit register,
such as APIs that return a 64-bit value. In this scenario, the return value is
populated in a memory buffer that is passed in as an argument. For example,
see the implementation of <code class="xref c c-func docutils literal"><span class="pre">_syscall_ret64_invoke0()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">_syscall_ret64_invoke1()</span></code>.</p>
</div>
</div>
<div class="section" id="implementation-function">
<h2>Implementation Function<a class="headerlink" href="#implementation-function" title="Permalink to this headline">¶</a></h2>
<p>The implementation function is what actually does the work for the API.
Zephyr normally does little to no error checking of arguments, or does this
kind of checking with assertions. When writing the implementation function,
validation of any parameters is optional and should be done with assertions.</p>
<p>All implementation functions must follow the naming convention, which is the
name of the API prefixed with <code class="docutils literal"><span class="pre">_impl_</span></code>. Implementation functions may be
declared in the same header as the API as a static inline function or
declared in some C file. There is no prototype needed for implementation
functions, these are automatically generated.</p>
</div>
<div class="section" id="handler-function">
<h2>Handler Function<a class="headerlink" href="#handler-function" title="Permalink to this headline">¶</a></h2>
<p>The handler function runs on the kernel side when a user thread makes
a system call. When the user thread makes a software interrupt to elevate to
supervisor mode, the common system call entry point uses the system call ID
provided by the user to look up the appropriate handler function for that
system call and jump into it.</p>
<p>Handler functions only run when system call APIs are invoked from user mode.
If an API is invoked from supervisor mode, the implementation is simply called.</p>
<p>The purpose of the handler function is to validate all the arguments passed in.
This includes:</p>
<ul class="simple">
<li>Any kernel object pointers provided. For example, the semaphore APIs must
ensure that the semaphore object passed in is a valid semaphore and that
the calling thread has permission on it.</li>
<li>Any memory buffers passed in from user mode. Checks must be made that the
calling thread has read or write permissions on the provided buffer.</li>
<li>Any other arguments that have a limited range of valid values.</li>
</ul>
<p>Handler functions involve a great deal of boilerplate code which has been
made simpler by some macros in <code class="docutils literal"><span class="pre">kernel/include/syscall_handlers.h</span></code>.
Handler functions should be declared using these macros.</p>
<div class="section" id="argument-validation">
<h3>Argument Validation<a class="headerlink" href="#argument-validation" title="Permalink to this headline">¶</a></h3>
<p>Several macros exist to validate arguments:</p>
<ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ()</span></code> Checks a memory address to assert that it is
a valid kernel object of the expected type, that the calling thread
has permissions on it, and that the object is initialized.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ_INIT()</span></code> is the same as
<code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ()</span></code>, except that the provided object may be
uninitialized. This is useful for handlers of object init functions.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ_NEVER_INIT()</span></code> is the same as
<code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ()</span></code>, except that the provided object must be
uninitialized. This is not used very often, currently only for
<code class="xref c c-func docutils literal"><span class="pre">k_thread_create()</span></code>.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_READ()</span></code> validates a memory buffer of a particular
size. The calling thread must have read permissions on the entire buffer.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_WRITE()</span></code> is the same as
<code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_READ()</span></code> but the calling thread must additionally
have write permissions.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_ARRAY_READ()</span></code> validates an array whose total size
is expressed as separate arguments for the number of elements and the
element size. This macro correctly accounts for multiplication overflow
when computing the total size. The calling thread must have read permissions
on the total size.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_ARRAY_WRITE()</span></code> is the same as
<code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_ARRAY_READ()</span></code> but the calling thread must
additionally have write permissions.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_VERIFY_MSG()</span></code> does a runtime check of some boolean
expression which must evaluate to true otherwise the check will fail.
A variant <code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_VERIFY</span></code> exists which does not take
a message parameter, instead printing the expression tested if it
fails. The latter should only be used for the most obvious of tests.</li>
</ul>
<p>If any check fails, a kernel oops will be triggered which will kill the
calling thread. This is done instead of returning some error condition to
keep the APIs the same when calling from supervisor mode.</p>
</div>
<div class="section" id="handler-declaration">
<h3>Handler Declaration<a class="headerlink" href="#handler-declaration" title="Permalink to this headline">¶</a></h3>
<p>All handler functions have the same prototype:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">u32_t</span> <span class="n">_handler_</span><span class="o">&lt;</span><span class="n">API</span> <span class="n">name</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u32_t</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">u32_t</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">u32_t</span> <span class="n">arg3</span><span class="p">,</span>
                          <span class="n">u32_t</span> <span class="n">arg4</span><span class="p">,</span> <span class="n">u32_t</span> <span class="n">arg5</span><span class="p">,</span> <span class="n">u32_t</span> <span class="n">arg6</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ssf</span><span class="p">)</span>
</pre></div>
</div>
<p>All handlers return a value. Handlers are passed exactly six arguments, which
were sent from user mode to the kernel via registers in the
architecture-specific system call implementation, plus an opaque context
pointer which indicates the system state when the system call was invoked from
user code.</p>
<p>To simplify the prototype, the variadic <code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER()</span></code> macro
should be used to declare the handler name and names of each argument. Type
information is not necessary since all arguments and the return value are
<code class="xref c c-type docutils literal"><span class="pre">u32_t</span></code>. Using <code class="xref c c-func docutils literal"><span class="pre">k_sem_init()</span></code> as an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">_SYSCALL_HANDLER</span><span class="p">(</span><span class="n">k_sem_init</span><span class="p">,</span> <span class="n">sem</span><span class="p">,</span> <span class="n">initial_count</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After validating all the arguments, the handler function needs to then call
the implementation function. If the implementation function returns a value,
this needs to be returned by the handler, otherwise the handler should return
0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Do not forget that all the arguments to the handler are passed in as
unsigned 32-bit values.  If checks are needed on parameters that are
actually signed values, casts may be needed in order for these checks to
be performed properly.</p>
</div>
<p>Using <code class="xref c c-func docutils literal"><span class="pre">k_sem_init()</span></code> as an example again, we need to enforce that the
semaphore object passed in is a valid semaphore object (but not necessarily
initialized), and that the limit parameter is nonzero:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">_SYSCALL_HANDLER</span><span class="p">(</span><span class="n">k_sem_init</span><span class="p">,</span> <span class="n">sem</span><span class="p">,</span> <span class="n">initial_count</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_SYSCALL_OBJ_INIT</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="n">K_OBJ_SEM</span><span class="p">);</span>
    <span class="n">_SYSCALL_VERIFY</span><span class="p">(</span><span class="n">limit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">_impl_k_sem_init</span><span class="p">((</span><span class="k">struct</span> <span class="n">k_sem</span> <span class="o">*</span><span class="p">)</span><span class="n">sem</span><span class="p">,</span> <span class="n">initial_count</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="simple-handler-declarations">
<h4>Simple Handler Declarations<a class="headerlink" href="#simple-handler-declarations" title="Permalink to this headline">¶</a></h4>
<p>Many kernel or driver APIs have very simple handler functions, where they
either accept no arguments, or take one object which is a kernel object
pointer of some specific type. Some special macros have been defined for
these simple cases, with variants depending on whether the API has a return
value:</p>
<ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER1_SIMPLE()</span></code> one kernel object argument, returns
a value</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER1_SIMPLE_VOID()</span></code> one kernel object argument,
no return value</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER0_SIMPLE()</span></code> no arguments, returns a value</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER0_SIMPLE_VOID()</span></code> no arguments, no return value</li>
</ul>
<p>For example, <code class="xref c c-func docutils literal"><span class="pre">k_sem_count_get()</span></code> takes a semaphore object as its
only argument and returns a value, so its handler can be completely expressed
as:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">_SYSCALL_HANDLER1_SIMPLE</span><span class="p">(</span><span class="n">k_sem_count_get</span><span class="p">,</span> <span class="n">K_OBJ_SEM</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sem</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="system-calls-with-6-or-more-arguments">
<h3>System Calls With 6 Or More Arguments<a class="headerlink" href="#system-calls-with-6-or-more-arguments" title="Permalink to this headline">¶</a></h3>
<p>System calls may have more than six arguments, however the number of arguments
passed in via registers when the privilege elevation is invoked is fixed at six
for all architectures. In this case, the sixth and subsequent arguments to the
system call are placed into a struct, and a pointer to that struct is passed to
the handler as its sixth argument.</p>
<p>See <code class="docutils literal"><span class="pre">include/syscall.h</span></code> to see how this is done; the struct passed in must be
validated like any other memory buffer. For example, for a system call
with nine arguments, arguments 6 through 9 will be passed in via struct, which
must be verified since memory pointers from user mode can be incorrect or
malicious:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">_SYSCALL_HANDLER</span><span class="p">(</span><span class="n">k_foo</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="n">arg5</span><span class="p">,</span> <span class="n">more_args_ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">_syscall_9_args</span> <span class="o">*</span><span class="n">margs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_syscall_9_args</span> <span class="o">*</span><span class="p">)</span><span class="n">more_args_ptr</span><span class="p">;</span>

    <span class="n">_SYSCALL_MEMORY_READ</span><span class="p">(</span><span class="n">margs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">margs</span><span class="p">));</span>

    <span class="p">...</span>

 <span class="p">}</span>
</pre></div>
</div>
<p>It is also very important to note that arguments passed in this way can change
at any time due to concurrent access to the argument struct. If any parameters
are subject to enforcement checks, they need to be copied out of the struct and
only then checked. One way to ensure this isn’t optimized out is to declare the
argument struct as <code class="docutils literal"><span class="pre">volatile</span></code>, and copy values out of it into local variables
before checking. Using the previous example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">_SYSCALL_HANDLER</span><span class="p">(</span><span class="n">k_foo</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="n">arg5</span><span class="p">,</span> <span class="n">more_args_ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="k">struct</span> <span class="n">_syscall_9_args</span> <span class="o">*</span><span class="n">margs</span> <span class="o">=</span>
                    <span class="p">(</span><span class="k">struct</span> <span class="n">_syscall_9_args</span> <span class="o">*</span><span class="p">)</span><span class="n">more_args_ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">arg8</span><span class="p">;</span>

    <span class="n">_SYSCALL_MEMORY_READ</span><span class="p">(</span><span class="n">margs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">margs</span><span class="p">));</span>
    <span class="n">arg8</span> <span class="o">=</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">arg8</span><span class="p">;</span>
    <span class="n">_SYSCALL_VERIFY_MSG</span><span class="p">(</span><span class="n">arg8</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;arg8 must be less than 12&quot;</span><span class="p">);</span>

    <span class="n">_impl_k_foo</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">,</span> <span class="n">arg5</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">arg6</span><span class="p">,</span>
                <span class="n">margs</span><span class="o">-&gt;</span><span class="n">arg7</span><span class="p">,</span> <span class="n">arg8</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">arg9</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="system-calls-with-64-bit-return-value">
<h3>System Calls With 64-bit Return Value<a class="headerlink" href="#system-calls-with-64-bit-return-value" title="Permalink to this headline">¶</a></h3>
<p>If a system call has a return value larger than 32-bits, the handler will not
return anything. Instead, a pointer to a sufficient memory region for the
return value will be passed in as an additional argument. As an example, we
have the system call for getting the current system uptime:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">__syscall</span> <span class="n">s64_t</span> <span class="nf">k_uptime_get</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>The handler function has the return area passed in as a pointer, which must
be validated as writable by the calling thread:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">_SYSCALL_HANDLER</span><span class="p">(</span><span class="n">k_uptime_get</span><span class="p">,</span> <span class="n">ret_p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">s64_t</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ret_p</span><span class="p">;</span>

    <span class="n">_SYSCALL_MEMORY_WRITE</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">));</span>
    <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">_impl_k_uptime_get</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="configuration-options">
<h2>Configuration Options<a class="headerlink" href="#configuration-options" title="Permalink to this headline">¶</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><a class="reference internal" href="../../reference/kconfig/CONFIG_USERSPACE.html#cmdoption-arg-config-userspace"><code class="xref std std-option docutils literal"><span class="pre">CONFIG_USERSPACE</span></code></a></li>
</ul>
</div>
<div class="section" id="apis">
<h2>APIs<a class="headerlink" href="#apis" title="Permalink to this headline">¶</a></h2>
<p>Helper macros for creating system call handlers are provided in
<code class="file docutils literal"><span class="pre">kernel/include/syscall_handler.h</span></code>:</p>
<ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER1_SIMPLE()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER1_SIMPLE_VOID()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER0_SIMPLE()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_HANDLER0_SIMPLE_VOID()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ_INIT()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_OBJ_NEVER_INIT()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_READ()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_WRITE()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_ARRAY_READ()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_MEMORY_ARRAY_WRITE()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_VERIFY_MSG()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">_SYSCALL_VERIFY</span></code></li>
</ul>
<p>Functions for invoking system calls are defined in
<code class="file docutils literal"><span class="pre">include/syscall.h</span></code>:</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke0()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke1()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke2()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke3()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke4()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke5()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_arch_syscall_invoke6()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_syscall_invoke7()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_syscall_invoke8()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_syscall_invoke9()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_syscall_invoke10()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_syscall_ret64_invoke0()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">_syscall_ret64_invoke1()</span></code></li>
</ul>
</div>
</div>


                </div>
              </div>
              <!-- 
  <div class="rst-footer-buttons row" role="navigation" aria-label="footer navigation">
    
      <a href="memory_domain.html" class="btn btn-neutral float-right" title="Memory Domain" accesskey="n">
        Next <span class="fa fa-arrow-circle-right"></span>
      </a>
    
    
      <a href="kernelobjects.html" class="btn btn-neutral" title="Kernel Objects" accesskey="p">
        <span class="fa fa-arrow-circle-left"></span> Previous
      </a>
    
  </div>
  for ZEP-463 remove the prev/next links -->
            </div>
            <!-- ENDS #content SECTION -->
          </section>
          <!-- ENDS .content -->
        </div>
        <!-- ENDS .main-container -->
      </div>
      <!-- ENDS #main -->
      <footer id="footer">
  <div class="container">
    <div class="block block-menu block-odd first block" data-bid="menu-footer-menu">
      <h3 class="title">Footer Menu</h3>
      <ul class="menu">
        <li class="leaf google- mid-2404">
          <a href="https://plus.google.com/+ZephyrProject" class="google-plus"><span>Google+</span></a>
        </li>
        <li class="leaf twitter mid-2405">
          <a href="https://twitter.com/zephyriot" class="twitter"><span>Twitter</span></a>
        </li>
        <li class="last leaf email mid-2406">
          <a href="mailto:info@zephyrproject.org" class="email"><span>Email</span></a>
        </li>
      </ul>
    </div>
    <div class="block block-block block-even block" data-bid="block-4">
      <p>
        Zephyr Project © 2018 is a Linux Foundation Project. All Rights Reserved.
      </p>
      <p>
        <a href="https://linuxfoundation.org" target="_blank">Linux Foundation</a> is a registered trademark of The Linux Foundation. Linux is a registered <a href="https://www.linuxfoundation.org/about/linux-foundation-trademark-usage-guidelines" target="_blank">trademark</a> of Linus Torvalds.
      </p>
      <p>
        Please see our <a href="https://www.linuxfoundation.org/privacy" target="_blank">privacy policy</a> and <a href="https://www.linuxfoundation.org/terms" target="_blank">terms of use</a>
      </p>
    </div>
  </div>
</footer>
    </div>
    <!-- ENDS #page -->

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.10.99',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/js/main.js"></script>
      <script type="text/javascript" src="../../_static/js/app.js"></script>
      <script type="text/javascript" src="../../_static/js/affix.js"></script>

   

  </body>
</html>