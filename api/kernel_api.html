

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en" > <!--<![endif]-->
  <head>
    <meta charset="utf-8">
   <!-- Google Tag Manager -->
   <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
   new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
   j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
   })(window,document,'script','dataLayer','GTM-KMP8MS');</script>
   <!-- End Google Tag Manager -->
    <link rel="apple-touch-icon" sizes="57x57" href="../_static/img/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../_static/img/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../_static/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../_static/img/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../_static/img/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../_static/img/apple-touch-icon-120x120.png">
    <link rel="icon" type="image/png" href="../_static/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../_static/img/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="../_static/img/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="../_static/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Zephyr Project">
    <meta name="application-name" content="Zephyr Project">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    
    <title>Kernel APIs &mdash; Zephyr Project Documentation</title>
    

    
    

    

    
    
      
    

    
    
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    

    
      <link rel="stylesheet" href="../_static/zephyr-custom.css" type="text/css" />
    
      <link rel="stylesheet" href="../_static/css/normalize.css" type="text/css" />
    
      <link rel="stylesheet" href="../_static/css/layout.css" type="text/css" />
    
      <link rel="stylesheet" href="../_static/css/main.css" type="text/css" />
    
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    

    
        <link rel="index" title="Index" href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
        <link rel="copyright" title="Copyright" href="../copyright.html"/>
      <link rel="top" title="Zephyr Project Documentation" href="../index.html"/>
        <link rel="up" title="API Documentation" href="api.html"/>
        <link rel="next" title="Device Driver Interface" href="device.html"/>
        <link rel="prev" title="API Documentation" href="api.html"/> 

    
    <script src="../_static/js/modernizr.min.js"></script>

  </head>

  <body class="not-front page-documentation one-sidebar sidebar-first" role="document" >
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KMP8MS"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="page">
      <header id="header">
  <div class="header-wrapper">
    <div class="container">
      <a href="https://zephyrproject.org/" title="Zephyr Project" rel="home" id="logo">
        <img src="../_static/img/logo_white.png" alt="Zephyr Project">
      </a>
      <a href="" id="navigation-toggle">
        <span> </span>
        Menu
      </a>
      <nav id="navigation" class="menu with-primary with-secondary">
        <ul class="header-menu main-menu">
          <li class="first expanded about mid-1209"><a href="https://zephyrproject.org/about/"><span>About</span></a>
            <ul class="menu">
              <li class="first leaf what-is-zephyr mid-2563"><a href="https://zephyrproject.org/what-is-zephyr/"><span>What is the Zephyr Project?</span></a></li>
              <li class="leaf organization mid-2564"><a href="https://zephyrproject.org/about/organization/"><span>Organization</span></a></li>
              <li class="leaf memberships mid-2532"><a href="https://zephyrproject.org/#members"><span>Members</span></a></li>
              <li class="leaf faq mid-2525"><a href="https://zephyrproject.org/about/#faq"><span>FAQ</span></a></li>
              <li class="leaf join mid-2622"><a href="https://zephyrproject.org/join/"><span>Join</span></a></li>
              <li class="last leaf contact-us mid-2530"><a href="https://zephyrproject.org/about/#contact-us"><span>Contact Us</span></a></li>
            </ul>
          </li>
          <li class="expanded developers mid-1209"><a href="https://zephyrproject.org/developers/"><span>Developers</span></a>
            <ul class="menu">
              <li class="first expanded leaf code mid-2563"><a href="https://github.com/zephyrproject-rtos/zephyr/" target="_blank"><span>Code</span></a></li>
              <li class="leaf downloads mid-2564"><a href="https://zephyrproject.org/developers/#downloads"><span>Downloads</span></a></li>
              <li class="leaf documentation mid-2564"><a href="http://docs.zephyrproject.org/index.html" target="_blank"><span>Documentation</span></a></li>
              <li class="leaf supported-boards mid-2564"><a href="http://docs.zephyrproject.org/boards/boards.html" target="_blank"><span>Supported Boards</span></a></li>
              <li class="leaf releases-overview mid-2564"><a href="https://zephyrproject.org/developers/#releases-overview"><span>Releases Overview</span></a></li>
              <li class="leaf how-to-contribute mid-2564"><a href="https://zephyrproject.org/developers/how-to-contribute/"><span>How to Contribute</span></a></li>
              <li class="last leaf community-guidelines mid-2564"><a href="https://zephyrproject.org/developers/how-to-contribute/#community-guidelines"><span>Community Guidelines</span></a></li>
            </ul>
          </li>
          <li class="expanded news mid-1209"><a href="https://zephyrproject.org/news/"><span>News</span></a>
            <ul class="menu">
              <li class="first leaf announcements mid-2563"><a href="https://zephyrproject.org/news/announcements/"><span>Announcements</span></a></li>
              <li class="leaf blog mid-2563"><a href="https://zephyrproject.org/news/blog/"><span>Blog</span></a></li>
              <li class="last leaf events mid-2563"><a href="https://zephyrproject.org/events/"><span>Events</span></a></li>
            </ul>
          </li>
          <li class="last expanded project-resources mid-1209"><a href="https://zephyrproject.org/project-resources/"><span>Project Resources</span></a>
            <ul class="menu">
              <li class="first leaf presentations mid-2563"><a href="https://zephyrproject.org/project-resources/presentations/"><span>Presentations</span></a></li>
              <li class="leaf videos mid-2563"><a href="https://zephyrproject.org/project-resources/videos/"><span>Videos</span></a></li>
              <li class="leaf demos mid-2563"><a href="https://zephyrproject.org/project-resources/demos/"><span>Demos</span></a></li>
              <li class="leaf zephyr-in-market mid-2563"><a href="https://zephyrproject.org/project-resources/zephyr-in-market/"><span>Zephyr in Market</span></a></li>
              <li class="last leaf developer-tools mid-2563"><a href="https://zephyrproject.org/project-resources/developer-tools/"><span>Developer Tools</span></a></li>
            </ul>
          </li>
        </ul>
      </nav><!-- /navigation -->
    </div>
  </div>
</header><!-- /header -->
      <!-- STARTS #main -->
      <div id="main">
        <!-- STARTS .main-container -->
        <div class="main-container">
          

 



<!-- Docs -->





<div id="breadcrumb">
  <div class="container">
    <a href="/">Home</a> / 
    <a href="../index.html">Docs</a> /
      
          <a href="../application/index.html">Developer Guides</a> /
      
          <a href="api.html">API Documentation</a> /
      
  </div>
</div>
          <aside id="sidebar-first" class="container-sidebar">
            
            <span id="secondary-menu-button" class="">Documentation</span>
<div class="region region-sidebar">
  <div class="docs-menu">
  
    
    
        <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introducing_zephyr.html">Introducing Zephyr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/contribute.html">Contributing to the Zephyr Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel/kernel.html">Zephyr Kernel Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/security.html">Zephyr Project Security</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../application/index.html">Developer Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../porting/porting.html">Porting Guides</a></li>
<li class="toctree-l2"><a class="reference internal" href="../application/application.html">Application Development Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../samples/samples.html">Samples and Demos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/kconfig/index.html">Configuration Options Reference Guide</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="api.html">API Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Kernel APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="device.html">Device Driver Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="bluetooth.html">Bluetooth API</a></li>
<li class="toctree-l3"><a class="reference internal" href="networking.html">Networking API</a></li>
<li class="toctree-l3"><a class="reference internal" href="io_interfaces.html">Input / Output Driver APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management_api.html">Power Management APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="file_system.html">File System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="display_api.html">Display Interface APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_api.html">Miscellaneous APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../README.html">Zephyr documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../boards/boards.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devices/index.html">Device and Driver Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystems/subsystems.html">Subsystems</a></li>
</ul>

    
  
  </div>
<div role="search" class="sphinx-search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search documentation" class="search-documentation" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
</div>
          </aside>
          <!-- STARTS .content SECTION-->
          <section id="content" class="row">
            
	    
            <div class="rst-content">
              <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
                <div itemprop="articleBody">
                  
  <div class="section" id="kernel-apis">
<span id="id1"></span><h1>Kernel APIs<a class="headerlink" href="#kernel-apis" title="Permalink to this headline">¶</a></h1>
<p>This section contains APIs for the kernel’s core services,
as described in the <a class="reference internal" href="../kernel/kernel.html#kernel"><span class="std std-ref">Zephyr Kernel Primer</span></a>.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Unless otherwise noted these APIs can be used by threads, but not by ISRs.</p>
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#threads" id="id2">Threads</a></li>
<li><a class="reference internal" href="#workqueues" id="id3">Workqueues</a></li>
<li><a class="reference internal" href="#clocks" id="id4">Clocks</a></li>
<li><a class="reference internal" href="#timers" id="id5">Timers</a></li>
<li><a class="reference internal" href="#memory-slabs" id="id6">Memory Slabs</a></li>
<li><a class="reference internal" href="#memory-pools" id="id7">Memory Pools</a></li>
<li><a class="reference internal" href="#heap-memory-pool" id="id8">Heap Memory Pool</a></li>
<li><a class="reference internal" href="#semaphores" id="id9">Semaphores</a></li>
<li><a class="reference internal" href="#mutexes" id="id10">Mutexes</a></li>
<li><a class="reference internal" href="#alerts" id="id11">Alerts</a></li>
<li><a class="reference internal" href="#fifos" id="id12">Fifos</a></li>
<li><a class="reference internal" href="#lifos" id="id13">Lifos</a></li>
<li><a class="reference internal" href="#stacks" id="id14">Stacks</a></li>
<li><a class="reference internal" href="#queues" id="id15">Queues</a></li>
<li><a class="reference internal" href="#message-queues" id="id16">Message Queues</a></li>
<li><a class="reference internal" href="#mailboxes" id="id17">Mailboxes</a></li>
<li><a class="reference internal" href="#pipes" id="id18">Pipes</a></li>
<li><a class="reference internal" href="#asynchronous-polling" id="id19">Asynchronous Polling</a></li>
<li><a class="reference internal" href="#interrupt-service-routines-isrs" id="id20">Interrupt Service Routines (ISRs)</a></li>
<li><a class="reference internal" href="#atomic-services" id="id21">Atomic Services</a></li>
<li><a class="reference internal" href="#profiling" id="id22">Profiling</a></li>
<li><a class="reference internal" href="#floating-point-services" id="id23">Floating Point Services</a></li>
<li><a class="reference internal" href="#ring-buffers" id="id24">Ring Buffers</a></li>
<li><a class="reference internal" href="#memory-domain" id="id25">Memory Domain</a></li>
</ul>
</div>
<div class="section" id="threads">
<h2><a class="toc-backref" href="#contents">Threads</a><a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h2>
<p>A thread is an independently scheduled series of instructions that implements
a portion of an application’s processing. Threads are used to perform processing
that is too lengthy or too complex to be performed by an ISR.
(See <a class="reference internal" href="../kernel/threads/threads.html#threads-v2"><span class="std std-ref">Threads</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d6/de7/group__thread__apis"></span><em>group</em> <code class="descname">thread_apis</code></dt>
<dd><p>end defgroup profiling_apis</p>
<p>end addtogroup isr_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_ESSENTIAL">
<span class="target" id="d6/de7/group__thread__apis_1gad503fbcca905a9266b0e154e3ded258c"></span><code class="descname">K_ESSENTIAL</code><a class="headerlink" href="#c.K_ESSENTIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_USER">
<span class="target" id="d6/de7/group__thread__apis_1gacb5340339892f22301e02697c6039ccc"></span><code class="descname">K_USER</code><a class="headerlink" href="#c.K_USER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_INHERIT_PERMS">
<span class="target" id="d6/de7/group__thread__apis_1gaa1788a413a055745d1de71b4da7c2eb2"></span><code class="descname">K_INHERIT_PERMS</code><a class="headerlink" href="#c.K_INHERIT_PERMS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_THREAD_DEFINE">
<span class="target" id="d6/de7/group__thread__apis_1gab3ced58648ca35788a40676e8478ecd2"></span><code class="descname">K_THREAD_DEFINE</code><span class="sig-paren">(</span>name, stack_size, entry, p1, p2, p3, prio, options, delay<span class="sig-paren">)</span><a class="headerlink" href="#c.K_THREAD_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a thread. </p>
<p>The thread may be scheduled for immediate execution or a delayed start.</p>
<p>Thread options are architecture-specific, and can include K_ESSENTIAL, K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating them using “|” (the logical OR operator).</p>
<p>The ID of the thread can be accessed using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">const</span> <span class="n">k_tid_t</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the thread. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Stack size in bytes. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Thread entry function. </li>
<li><code class="docutils literal"><span class="pre">p1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p3</span></code>: 3rd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Thread priority. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Thread options. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Scheduling delay (in milliseconds), or K_NO_WAIT (for no delay). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv215k_thread_createP8k_threadP16k_thread_stack_t6size_t16k_thread_entry_tPvPvPvi5u32_t5s32_t">
<span id="k_thread_create__k_threadP.k_thread_stack_tP.s.k_thread_entry_t.voidP.voidP.voidP.i.u32_t.s32_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga1ef859e1f5167f48469f45c3ad3358b5"></span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <code class="descname">k_thread_create</code><span class="sig-paren">(</span><em class="property">struct</em> k_thread *<em>new_thread</em>, k_thread_stack_t *<em>stack</em>, size_t <em>stack_size</em>, k_thread_entry_t <em>entry</em>, void *<em>p1</em>, void *<em>p2</em>, void *<em>p3</em>, int <em>prio</em>, u32_t <em>options</em>, s32_t <em>delay</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_thread_createP8k_threadP16k_thread_stack_t6size_t16k_thread_entry_tPvPvPvi5u32_t5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a thread. </p>
<p>This routine initializes a thread, then schedules it for execution.</p>
<p>The new thread may be scheduled for immediate execution or a delayed start. If the newly spawned thread does not have a delayed start the kernel scheduler may preempt the current thread to allow the new thread to execute.</p>
<p>Thread options are architecture-specific, and can include K_ESSENTIAL, K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating them using “|” (the logical OR operator).</p>
<p>Historically, users often would use the beginning of the stack memory region to store the struct k_thread data, although corruption will occur if the stack overflows this region and stack protection features may not detect this situation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>ID of new thread. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">new_thread</span></code>: Pointer to uninitialized struct k_thread </li>
<li><code class="docutils literal"><span class="pre">stack</span></code>: Pointer to the stack space. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Stack size in bytes. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Thread entry function. </li>
<li><code class="docutils literal"><span class="pre">p1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p3</span></code>: 3rd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Thread priority. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Thread options. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Scheduling delay (in milliseconds), or K_NO_WAIT (for no delay).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224k_thread_user_mode_enter16k_thread_entry_tPvPvPv">
<span id="k_thread_user_mode_enter__k_thread_entry_t.voidP.voidP.voidP"></span><span class="target" id="d6/de7/group__thread__apis_1ga3fbe1c8a5f3ef1c25382c7d6fca35764"></span>FUNC_NORETURN void <code class="descname">k_thread_user_mode_enter</code><span class="sig-paren">(</span>k_thread_entry_t <em>entry</em>, void *<em>p1</em>, void *<em>p2</em>, void *<em>p3</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv224k_thread_user_mode_enter16k_thread_entry_tPvPvPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Drop a thread’s privileges permanently to user mode. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">entry</span></code>: Function to start executing from </li>
<li><code class="docutils literal"><span class="pre">p1</span></code>: 1st entry point parameter </li>
<li><code class="docutils literal"><span class="pre">p2</span></code>: 2nd entry point parameter </li>
<li><code class="docutils literal"><span class="pre">p3</span></code>: 3rd entry point parameter </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_thread_access_grantP8k_threadz">
<span id="k_thread_access_grant__k_threadP.z"></span><span class="target" id="d6/de7/group__thread__apis_1ga09fd61efc61066f742fada3e4e74e5f1"></span>void <code class="descname">k_thread_access_grant</code><span class="sig-paren">(</span><em class="property">struct</em> k_thread *<em>thread</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_thread_access_grantP8k_threadz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Grant a thread access to a NULL-terminated set of kernel objects. </p>
<p>This is a convenience function. For the provided thread, grant access to the remaining arguments, which must be pointers to kernel objects. The final argument must be a NULL.</p>
<p>The thread object must be initialized (i.e. running). The objects don’t need to be.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: Thread to grant access to objects </li>
<li><code class="docutils literal"><span class="pre">...</span></code>: NULL-terminated list of kernel object pointers </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv27k_sleep5s32_t">
<span id="k_sleep__s32_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga17fd03ed4acf33453281f8396871e12c"></span>void <code class="descname">k_sleep</code><span class="sig-paren">(</span>s32_t <em>duration</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv27k_sleep5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Put the current thread to sleep. </p>
<p>This routine puts the current thread to sleep for <em>duration</em> milliseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">duration</span></code>: Number of milliseconds to sleep.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_busy_wait5u32_t">
<span id="k_busy_wait__u32_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga357e7ff19fedaf849faf4e13c7fe36a1"></span>void <code class="descname">k_busy_wait</code><span class="sig-paren">(</span>u32_t <em>usec_to_wait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_busy_wait5u32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cause the current thread to busy wait. </p>
<p>This routine causes the current thread to execute a “do nothing” loop for <em>usec_to_wait</em> microseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv27k_yieldv">
<span id="k_yield__void"></span><span class="target" id="d6/de7/group__thread__apis_1ga08a3484c33444ecedc2d71d78495a295"></span>void <code class="descname">k_yield</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv27k_yieldv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Yield the current thread. </p>
<p>This routine causes the current thread to yield execution to another thread of the same or higher priority. If there are no other ready threads of the same or higher priority, the routine returns immediately.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28k_wakeup7k_tid_t">
<span id="k_wakeup__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga9275a019c8ff3c7fe49a81f8c078157e"></span>void <code class="descname">k_wakeup</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv28k_wakeup7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wake up a sleeping thread. </p>
<p>This routine prematurely wakes up <em>thread</em> from sleeping.</p>
<p>If <em>thread</em> is not currently sleeping, the routine has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to wake.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_current_getv">
<span id="k_current_get__void"></span><span class="target" id="d6/de7/group__thread__apis_1ga3127f70fe54deec9bd5256ca5c360ecc"></span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <code class="descname">k_current_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv213k_current_getv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get thread ID of the current thread. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>ID of current thread. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_thread_cancel7k_tid_t">
<span id="k_thread_cancel__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga7259319d3a8a86a491a0a8f1d1a671e4"></span>int <code class="descname">k_thread_cancel</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_thread_cancel7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel thread performing a delayed start. </p>
<p>This routine prevents <em>thread</em> from executing if it has not yet started execution. The thread must be re-spawned before it will execute.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to cancel.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Thread spawning canceled. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Thread has already started executing. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_thread_abort7k_tid_t">
<span id="k_thread_abort__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga1f44bb0307bea7a97227764ecd7bf963"></span>void <code class="descname">k_thread_abort</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_thread_abort7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Abort a thread. </p>
<p>This routine permanently stops execution of <em>thread</em>. The thread is taken off all kernel queues it is part of (i.e. the ready queue, the timeout queue, or a kernel object wait queue). However, any kernel resources the thread might currently own (such as mutexes or memory blocks) are not released. It is the responsibility of the caller of this routine to ensure all necessary cleanup is performed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to abort.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_thread_start7k_tid_t">
<span id="k_thread_start__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga88031bd9fcfcd4305bae4029a4d8416f"></span>void <code class="descname">k_thread_start</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_thread_start7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start an inactive thread. </p>
<p>If a thread was created with K_FOREVER in the delay parameter, it will not be added to the scheduling queue until this function is called on it.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: thread to start </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_thread_priority_get7k_tid_t">
<span id="k_thread_priority_get__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga3a46ed8ad2c3b12416fafe11325f82b3"></span>int <code class="descname">k_thread_priority_get</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_thread_priority_get7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a thread’s priority. </p>
<p>This routine gets the priority of <em>thread</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Priority of <em>thread</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread whose priority is needed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_thread_priority_set7k_tid_ti">
<span id="k_thread_priority_set__k_tid_t.i"></span><span class="target" id="d6/de7/group__thread__apis_1ga24e50a60c524d1eb22fe21cdf269b6a6"></span>void <code class="descname">k_thread_priority_set</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em>, int <em>prio</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_thread_priority_set7k_tid_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a thread’s priority. </p>
<p>This routine immediately changes the priority of <em>thread</em>.</p>
<p>Rescheduling can occur immediately depending on the priority <em>thread</em> is set to:</p>
<p><ul class="simple">
<li>If its priority is raised above the priority of the caller of this function, and the caller is preemptible, <em>thread</em> will be scheduled in.</li>
<li>If the caller operates on itself, it lowers its priority below that of other threads in the system, and the caller is preemptible, the thread of highest priority will be scheduled in.</li>
</ul>
</p>
<p>Priority can be assigned in the range of -CONFIG_NUM_COOP_PRIORITIES to CONFIG_NUM_PREEMPT_PRIORITIES-1, where -CONFIG_NUM_COOP_PRIORITIES is the highest priority.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Changing the priority of a thread currently involved in mutex priority inheritance may result in undefined behavior.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread whose priority is to be set. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: New priority.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_thread_suspend7k_tid_t">
<span id="k_thread_suspend__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga66cf8682fb65870eceb5e57d667a8d4e"></span>void <code class="descname">k_thread_suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216k_thread_suspend7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspend a thread. </p>
<p>This routine prevents the kernel scheduler from making <em>thread</em> the current thread. All other internal operations on <em>thread</em> are still performed; for example, any timeout it is waiting on keeps ticking, kernel objects it is waiting on are still handed to it, etc.</p>
<p>If <em>thread</em> is already suspended, the routine has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to suspend.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_thread_resume7k_tid_t">
<span id="k_thread_resume__k_tid_t"></span><span class="target" id="d6/de7/group__thread__apis_1ga117b26f8569ec3045ead1fad1851663d"></span>void <code class="descname">k_thread_resume</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_thread_resume7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resume a suspended thread. </p>
<p>This routine allows the kernel scheduler to make <em>thread</em> the current thread, when it is next eligible for that role.</p>
<p>If <em>thread</em> is not currently suspended, the routine has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to resume.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222k_sched_time_slice_set5s32_ti">
<span id="k_sched_time_slice_set__s32_t.i"></span><span class="target" id="d6/de7/group__thread__apis_1gac4f158e74cb1a3f7762bcd13e19d58aa"></span>void <code class="descname">k_sched_time_slice_set</code><span class="sig-paren">(</span>s32_t <em>slice</em>, int <em>prio</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv222k_sched_time_slice_set5s32_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set time-slicing period and scope. </p>
<p>This routine specifies how the scheduler will perform time slicing of preemptible threads.</p>
<p>To enable time slicing, <em>slice</em> must be non-zero. The scheduler ensures that no thread runs for more than the specified time limit before other threads of that priority are given a chance to execute. Any thread whose priority is higher than <em>prio</em> is exempted, and may execute as long as desired without being preempted due to time slicing.</p>
<p>Time slicing only limits the maximum amount of time a thread may continuously execute. Once the scheduler selects a thread for execution, there is no minimum guaranteed time the thread will execute before threads of greater or equal priority are scheduled.</p>
<p>When the current thread is the only one of that priority eligible for execution, this routine has no effect; the thread is immediately rescheduled after the slice period expires.</p>
<p>To disable timeslicing, set both <em>slice</em> and <em>prio</em> to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slice</span></code>: Maximum time slice length (in milliseconds). </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Highest thread priority level eligible for time slicing.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_sched_lockv">
<span id="k_sched_lock__void"></span><span class="target" id="d6/de7/group__thread__apis_1ga4f0c5d0b9f279b12a4ad97db0c116a5f"></span>void <code class="descname">k_sched_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_sched_lockv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock the scheduler. </p>
<p>This routine prevents the current thread from being preempted by another thread by instructing the scheduler to treat it as a cooperative thread. If the thread subsequently performs an operation that makes it unready, it will be context switched out in the normal manner. When the thread again becomes the current thread, its non-preemptible status is maintained.</p>
<p>This routine can be called recursively.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>k_sched_lock() and k_sched_unlock() should normally be used when the operation being performed can be safely interrupted by ISRs. However, if the amount of processing involved is very small, better performance may be obtained by using irq_lock() and irq_unlock().</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_sched_unlockv">
<span id="k_sched_unlock__void"></span><span class="target" id="d6/de7/group__thread__apis_1ga7b26f64523cc4c36522cc828ccf85580"></span>void <code class="descname">k_sched_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_sched_unlockv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock the scheduler. </p>
<p>This routine reverses the effect of a previous call to k_sched_lock(). A thread must call the routine once for each time it called k_sched_lock() before the thread becomes preemptible.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224k_thread_custom_data_setPv">
<span id="k_thread_custom_data_set__voidP"></span><span class="target" id="d6/de7/group__thread__apis_1ga4834d9b81ed60c00eee77b0d4f8ab9e4"></span>void <code class="descname">k_thread_custom_data_set</code><span class="sig-paren">(</span>void *<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv224k_thread_custom_data_setPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set current thread’s custom data. </p>
<p>This routine sets the custom data for the current thread to &#64; value.</p>
<p>Custom data is not used by the kernel itself, and is freely available for a thread to use as it sees fit. It can be used as a framework upon which to build thread-local storage.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">value</span></code>: New custom data value.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224k_thread_custom_data_getv">
<span id="k_thread_custom_data_get__void"></span><span class="target" id="d6/de7/group__thread__apis_1ga8a53350c009f408fdfcd5002437132ba"></span>void *<code class="descname">k_thread_custom_data_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv224k_thread_custom_data_getv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get current thread’s custom data. </p>
<p>This routine returns the custom data for the current thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current custom data value. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="workqueues">
<h2><a class="toc-backref" href="#contents">Workqueues</a><a class="headerlink" href="#workqueues" title="Permalink to this headline">¶</a></h2>
<p>A workqueue processes a series of work items by executing the associated
functions in a dedicated thread. Workqueues are typically used by an ISR
or high-priority thread to offload non-urgent processing.
(See <a class="reference internal" href="../kernel/threads/workqueues.html#workqueues-v2"><span class="std std-ref">Workqueue Threads</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="dc/d1c/group__workqueue__apis"></span><em>group</em> <code class="descname">workqueue_apis</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c._K_WORK_INITIALIZER">
<span class="target" id="dc/d1c/group__workqueue__apis_1ga71ef926cd9aac31a87a36596505ea639"></span><code class="descname">_K_WORK_INITIALIZER</code><span class="sig-paren">(</span>work_handler<span class="sig-paren">)</span><a class="headerlink" href="#c._K_WORK_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_WORK_INITIALIZER">
<span class="target" id="dc/d1c/group__workqueue__apis_1ga9067d00ef5d9d1c6513745beda29fef7"></span><code class="descname">K_WORK_INITIALIZER</code><a class="headerlink" href="#c.K_WORK_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_WORK_DEFINE">
<span class="target" id="dc/d1c/group__workqueue__apis_1gaf8e003eefa5dd66ba883688f9d39c333"></span><code class="descname">K_WORK_DEFINE</code><span class="sig-paren">(</span>work, work_handler<span class="sig-paren">)</span><a class="headerlink" href="#c.K_WORK_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a statically-defined work item. </p>
<p>This macro can be used to initialize a statically-defined workqueue work item, prior to its first use. For example,</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">K_WORK_DEFINE</span><span class="p">(</span><span class="o">&lt;</span><span class="n">work</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">work_handler</span><span class="o">&gt;</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Symbol name for work item object </li>
<li><code class="docutils literal"><span class="pre">work_handler</span></code>: Function to invoke each time work item is processed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv216k_work_handler_t">
<span id="k_work_handler_t"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gaf94f1a715b671c9de978ec277b911a50"></span><em class="property">typedef </em><code class="descname">k_work_handler_t</code><a class="headerlink" href="#_CPPv216k_work_handler_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Work item handler function type. </p>
<p>A work item’s handler function is executed by a workqueue’s thread when the work item is processed by the workqueue.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of the work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv211k_work_initP6k_work16k_work_handler_t">
<span id="k_work_init__k_workP.k_work_handler_t"></span><span class="target" id="dc/d1c/group__workqueue__apis_1ga5d448863f7f12300474d83713d035d0d"></span><em class="property">static</em> void <code class="descname">k_work_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em>, <a class="reference internal" href="#_CPPv216k_work_handler_t" title="k_work_handler_t">k_work_handler_t</a> <em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_work_initP6k_work16k_work_handler_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a work item. </p>
<p>This routine initializes a workqueue work item, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Function to invoke each time work item is processed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222k_work_submit_to_queueP8k_work_qP6k_work">
<span id="k_work_submit_to_queue__k_work_qP.k_workP"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gad8770c635132bf516a6b021464f51e1d"></span><em class="property">static</em> void <code class="descname">k_work_submit_to_queue</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>work_q</em>, <em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv222k_work_submit_to_queueP8k_work_qP6k_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a work item. </p>
<p>This routine submits work item <em>work</em> to be processed by workqueue <em>work_q</em>. If the work item is already pending in the workqueue’s queue as a result of an earlier submission, this routine has no effect on the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>A submitted work item must not be modified until it has been processed by the workqueue.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_q</span></code>: Address of workqueue. </li>
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_work_pendingP6k_work">
<span id="k_work_pending__k_workP"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gac44ae7f3b602c0b51e22b37dd6c8dd64"></span><em class="property">static</em> int <code class="descname">k_work_pending</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_work_pendingP6k_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a work item is pending. </p>
<p>This routine indicates if work item <em>work</em> is pending in a workqueue’s queue.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>1 if work item is pending, or 0 if it is not pending. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_work_q_startP8k_work_qP16k_thread_stack_t6size_ti">
<span id="k_work_q_start__k_work_qP.k_thread_stack_tP.s.i"></span><span class="target" id="dc/d1c/group__workqueue__apis_1ga5081e4bb22de8aa12d5a1064bfb94e4f"></span>void <code class="descname">k_work_q_start</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>work_q</em>, k_thread_stack_t *<em>stack</em>, size_t <em>stack_size</em>, int <em>prio</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_work_q_startP8k_work_qP16k_thread_stack_t6size_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start a workqueue. </p>
<p>This routine starts workqueue <em>work_q</em>. The workqueue spawns its work processing thread, which runs forever.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_q</span></code>: Address of workqueue. </li>
<li><code class="docutils literal"><span class="pre">stack</span></code>: Pointer to work queue thread’s stack space, as defined by K_THREAD_STACK_DEFINE() </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Size of the work queue thread’s stack (in bytes), which should either be the same constant passed to K_THREAD_STACK_DEFINE() or the value of K_THREAD_STACK_SIZEOF(). </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Priority of the work queue’s thread.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_delayed_work_initP14k_delayed_work16k_work_handler_t">
<span id="k_delayed_work_init__k_delayed_workP.k_work_handler_t"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gabc1ae700058df16c6a280c9f682caacd"></span>void <code class="descname">k_delayed_work_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em>, <a class="reference internal" href="#_CPPv216k_work_handler_t" title="k_work_handler_t">k_work_handler_t</a> <em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_delayed_work_initP14k_delayed_work16k_work_handler_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a delayed work item. </p>
<p>This routine initializes a workqueue delayed work item, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Function to invoke each time work item is processed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv230k_delayed_work_submit_to_queueP8k_work_qP14k_delayed_work5s32_t">
<span id="k_delayed_work_submit_to_queue__k_work_qP.k_delayed_workP.s32_t"></span><span class="target" id="dc/d1c/group__workqueue__apis_1ga9c0b1da06af73c8bd61f8b5e3e339c1c"></span>int <code class="descname">k_delayed_work_submit_to_queue</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>work_q</em>, <em class="property">struct</em> k_delayed_work *<em>work</em>, s32_t <em>delay</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv230k_delayed_work_submit_to_queueP8k_work_qP14k_delayed_work5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a delayed work item. </p>
<p>This routine schedules work item <em>work</em> to be processed by workqueue <em>work_q</em> after a delay of <em>delay</em> milliseconds. The routine initiates an asynchronous countdown for the work item and then returns to the caller. Only when the countdown completes is the work item actually submitted to the workqueue and becomes pending.</p>
<p>Submitting a previously submitted delayed work item that is still counting down cancels the existing submission and restarts the countdown using the new delay. If the work item is currently pending on the workqueue’s queue because the countdown has completed it is too late to resubmit the item, and resubmission fails without impacting the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>A delayed work item must not be modified until it has been processed by the workqueue.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_q</span></code>: Address of workqueue. </li>
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Delay before submitting the work item (in milliseconds).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Work item countdown started. </li>
<li><code class="docutils literal"><span class="pre">-EINPROGRESS</span></code>: Work item is already pending. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Work item is being processed or has completed its work. </li>
<li><code class="docutils literal"><span class="pre">-EADDRINUSE</span></code>: Work item is pending on a different workqueue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_delayed_work_cancelP14k_delayed_work">
<span id="k_delayed_work_cancel__k_delayed_workP"></span><span class="target" id="dc/d1c/group__workqueue__apis_1ga4a5d22d1317f77e1e5a61c7ddc314183"></span>int <code class="descname">k_delayed_work_cancel</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_delayed_work_cancelP14k_delayed_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel a delayed work item. </p>
<p>This routine cancels the submission of delayed work item <em>work</em>. A delayed work item can only be canceled while its countdown is still underway.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Work item countdown canceled. </li>
<li><code class="docutils literal"><span class="pre">-EINPROGRESS</span></code>: Work item is already pending. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Work item is being processed or has completed its work. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_work_submitP6k_work">
<span id="k_work_submit__k_workP"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gaef687f4052ee80cb24e4c5e1bb8512c3"></span><em class="property">static</em> void <code class="descname">k_work_submit</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv213k_work_submitP6k_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a work item to the system workqueue. </p>
<p>This routine submits work item <em>work</em> to be processed by the system workqueue. If the work item is already pending in the workqueue’s queue as a result of an earlier submission, this routine has no effect on the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Work items submitted to the system workqueue should avoid using handlers that block or yield since this may prevent the system workqueue from processing other work items in a timely manner.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_delayed_work_submitP14k_delayed_work5s32_t">
<span id="k_delayed_work_submit__k_delayed_workP.s32_t"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gaa7b16990d5fa3f8e58e77b4a69b1c334"></span><em class="property">static</em> int <code class="descname">k_delayed_work_submit</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em>, s32_t <em>delay</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_delayed_work_submitP14k_delayed_work5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a delayed work item to the system workqueue. </p>
<p>This routine schedules work item <em>work</em> to be processed by the system workqueue after a delay of <em>delay</em> milliseconds. The routine initiates an asynchronous countdown for the work item and then returns to the caller. Only when the countdown completes is the work item actually submitted to the workqueue and becomes pending.</p>
<p>Submitting a previously submitted delayed work item that is still counting down cancels the existing submission and restarts the countdown using the new delay. If the work item is currently pending on the workqueue’s queue because the countdown has completed it is too late to resubmit the item, and resubmission fails without impacting the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Work items submitted to the system workqueue should avoid using handlers that block or yield since this may prevent the system workqueue from processing other work items in a timely manner.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Delay before submitting the work item (in milliseconds).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Work item countdown started. </li>
<li><code class="docutils literal"><span class="pre">-EINPROGRESS</span></code>: Work item is already pending. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Work item is being processed or has completed its work. </li>
<li><code class="docutils literal"><span class="pre">-EADDRINUSE</span></code>: Work item is pending on a different workqueue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv228k_delayed_work_remaining_getP14k_delayed_work">
<span id="k_delayed_work_remaining_get__k_delayed_workP"></span><span class="target" id="dc/d1c/group__workqueue__apis_1gab397c3bd0a1964bdae1e66453654169a"></span><em class="property">static</em> s32_t <code class="descname">k_delayed_work_remaining_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv228k_delayed_work_remaining_getP14k_delayed_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get time remaining before a delayed work gets scheduled. </p>
<p>This routine computes the (approximate) time remaining before a delayed work gets executed. If the delayed work is not waiting to be scheduled, it returns zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Remaining time (in milliseconds). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Delayed work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="clocks">
<h2><a class="toc-backref" href="#contents">Clocks</a><a class="headerlink" href="#clocks" title="Permalink to this headline">¶</a></h2>
<p>Kernel clocks enable threads and ISRs to measure the passage of time
with either normal and high precision.
(See <a class="reference internal" href="../kernel/timing/clocks.html#clocks-v2"><span class="std std-ref">Kernel Clocks</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="de/dca/group__clock__apis"></span><em>group</em> <code class="descname">clock_apis</code></dt>
<dd><p>end addtogroup thread_apis</p>
<p>end defgroup timer_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_NO_WAIT">
<span class="target" id="de/dca/group__clock__apis_1ga3d9541cfe2e8395af66d186efa77362f"></span><code class="descname">K_NO_WAIT</code><a class="headerlink" href="#c.K_NO_WAIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate null timeout delay. </p>
<p>This macro generates a timeout delay that that instructs a kernel API not to wait if the requested operation cannot be performed immediately.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MSEC">
<span class="target" id="de/dca/group__clock__apis_1ga302af954e87b10a9b731f1ad07775e9f"></span><code class="descname">K_MSEC</code><span class="sig-paren">(</span>ms<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MSEC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate timeout delay from milliseconds. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>ms</em> milliseconds to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ms</span></code>: Duration in milliseconds.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_SECONDS">
<span class="target" id="de/dca/group__clock__apis_1gadc361472aea59267f6ea38f5e7c7ca2a"></span><code class="descname">K_SECONDS</code><span class="sig-paren">(</span>s<span class="sig-paren">)</span><a class="headerlink" href="#c.K_SECONDS" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate timeout delay from seconds. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>s</em> seconds to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">s</span></code>: Duration in seconds.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MINUTES">
<span class="target" id="de/dca/group__clock__apis_1gaef02f20d4d2ebfc9aa29acae01bd3698"></span><code class="descname">K_MINUTES</code><span class="sig-paren">(</span>m<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MINUTES" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate timeout delay from minutes. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>m</em> minutes to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">m</span></code>: Duration in minutes.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_HOURS">
<span class="target" id="de/dca/group__clock__apis_1gaa9e0cd890db28965b66d4bc5d719a91f"></span><code class="descname">K_HOURS</code><span class="sig-paren">(</span>h<span class="sig-paren">)</span><a class="headerlink" href="#c.K_HOURS" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate timeout delay from hours. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>h</em> hours to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">h</span></code>: Duration in hours.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_FOREVER">
<span class="target" id="de/dca/group__clock__apis_1ga0bb4b83f0222193b21a8910311bab0ca"></span><code class="descname">K_FOREVER</code><a class="headerlink" href="#c.K_FOREVER" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate infinite timeout delay. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait as long as necessary to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_enable_sys_clock_always_on">
<span class="target" id="de/dca/group__clock__apis_1gaa617b1062aac0fa4587bd18c5592fcaa"></span><code class="descname">k_enable_sys_clock_always_on</code><a class="headerlink" href="#c.k_enable_sys_clock_always_on" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.k_disable_sys_clock_always_on">
<span class="target" id="de/dca/group__clock__apis_1gaf82bd83be208b8937ac36fcf047cde26"></span><code class="descname">k_disable_sys_clock_always_on</code><a class="headerlink" href="#c.k_disable_sys_clock_always_on" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.k_cycle_get_32">
<span class="target" id="de/dca/group__clock__apis_1ga4003bb1e7e350a190b89a9de79a67bec"></span><code class="descname">k_cycle_get_32</code><a class="headerlink" href="#c.k_cycle_get_32" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the hardware clock. </p>
<p>This routine returns the current time, as measured by the system’s hardware clock.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current hardware clock up-counter (in cycles). </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SYS_CLOCK_HW_CYCLES_TO_NS">
<span class="target" id="de/dca/group__clock__apis_1ga60b80bbea58a354fd814ca16f1dd51ec"></span><code class="descname">SYS_CLOCK_HW_CYCLES_TO_NS</code><span class="sig-paren">(</span>X<span class="sig-paren">)</span><a class="headerlink" href="#c.SYS_CLOCK_HW_CYCLES_TO_NS" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute nanoseconds from hardware clock cycles. </p>
<p>This macro converts a time duration expressed in hardware clock cycles to the equivalent duration expressed in nanoseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Duration in nanoseconds. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">X</span></code>: Duration in hardware clock cycles.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv212k_uptime_getv">
<span id="k_uptime_get__void"></span><span class="target" id="de/dca/group__clock__apis_1gaaa003e67161d2e564b918fe398c36d34"></span>s64_t <code class="descname">k_uptime_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_uptime_getv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get system uptime. </p>
<p>This routine returns the elapsed time since the system booted, in milliseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current uptime. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_uptime_get_32v">
<span id="k_uptime_get_32__void"></span><span class="target" id="de/dca/group__clock__apis_1gaf0362ea97ff2ac572faaf28279934518"></span>u32_t <code class="descname">k_uptime_get_32</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_uptime_get_32v" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get system uptime (32-bit version). </p>
<p>This routine returns the lower 32-bits of the elapsed time since the system booted, in milliseconds.</p>
<p>This routine can be more efficient than k_uptime_get(), as it reduces the need for interrupt locking and 64-bit math. However, the 32-bit result cannot hold a system uptime time larger than approximately 50 days, so the caller must handle possible rollovers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current uptime. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_uptime_deltaP5s64_t">
<span id="k_uptime_delta__s64_tP"></span><span class="target" id="de/dca/group__clock__apis_1gae48dde341203c920f7ee00645fe170fb"></span>s64_t <code class="descname">k_uptime_delta</code><span class="sig-paren">(</span>s64_t *<em>reftime</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_uptime_deltaP5s64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get elapsed time. </p>
<p>This routine computes the elapsed time between the current system uptime and an earlier reference time, in milliseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Elapsed time. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">reftime</span></code>: Pointer to a reference time, which is updated to the current uptime upon return.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217k_uptime_delta_32P5s64_t">
<span id="k_uptime_delta_32__s64_tP"></span><span class="target" id="de/dca/group__clock__apis_1ga41406fe8fefd31727c97da9d7c2533d0"></span>u32_t <code class="descname">k_uptime_delta_32</code><span class="sig-paren">(</span>s64_t *<em>reftime</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217k_uptime_delta_32P5s64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get elapsed time (32-bit version). </p>
<p>This routine computes the elapsed time between the current system uptime and an earlier reference time, in milliseconds.</p>
<p>This routine can be more efficient than k_uptime_delta(), as it reduces the need for interrupt locking and 64-bit math. However, the 32-bit result cannot hold an elapsed time larger than approximately 50 days, so the caller must handle possible rollovers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Elapsed time. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">reftime</span></code>: Pointer to a reference time, which is updated to the current uptime upon return.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="timers">
<h2><a class="toc-backref" href="#contents">Timers</a><a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h2>
<p>Timers enable threads to measure the passage of time, and to optionally execute
an action when the timer expires.
(See <a class="reference internal" href="../kernel/timing/timers.html#timers-v2"><span class="std std-ref">Timers</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d0/d15/group__timer__apis"></span><em>group</em> <code class="descname">timer_apis</code></dt>
<dd><p>end addtogroup clock_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_TIMER_DEFINE">
<span class="target" id="d0/d15/group__timer__apis_1gaa267fcb0a2e18cd0da29e9f9612510a6"></span><code class="descname">K_TIMER_DEFINE</code><span class="sig-paren">(</span>name, expiry_fn, stop_fn<span class="sig-paren">)</span><a class="headerlink" href="#c.K_TIMER_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a timer. </p>
<p>The timer can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_timer</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the timer variable. </li>
<li><code class="docutils literal"><span class="pre">expiry_fn</span></code>: Function to invoke each time the timer expires. </li>
<li><code class="docutils literal"><span class="pre">stop_fn</span></code>: Function to invoke if the timer is stopped while running. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv216k_timer_expiry_t">
<span id="k_timer_expiry_t"></span><span class="target" id="d0/d15/group__timer__apis_1ga37bcd42a457855a68b74570c979ababa"></span><em class="property">typedef </em><code class="descname">k_timer_expiry_t</code><a class="headerlink" href="#_CPPv216k_timer_expiry_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Timer expiry function type. </p>
<p>A timer’s expiry function is executed by the system clock interrupt handler each time the timer expires. The expiry function is optional, and is only invoked if the timer has been initialized with one.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv214k_timer_stop_t">
<span id="k_timer_stop_t"></span><span class="target" id="d0/d15/group__timer__apis_1ga16fbd44c08a26c4fdeb7f542f2a03a15"></span><em class="property">typedef </em><code class="descname">k_timer_stop_t</code><a class="headerlink" href="#_CPPv214k_timer_stop_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Timer stop function type. </p>
<p>A timer’s stop function is executed if the timer is stopped prematurely. The function runs in the context of the thread that stops the timer. The stop function is optional, and is only invoked if the timer has been initialized with one.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv212k_timer_initP7k_timer16k_timer_expiry_t14k_timer_stop_t">
<span id="k_timer_init__k_timerP.k_timer_expiry_t.k_timer_stop_t"></span><span class="target" id="d0/d15/group__timer__apis_1ga318c846a740b901e5d56876a47ad7f61"></span>void <code class="descname">k_timer_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, <a class="reference internal" href="#_CPPv216k_timer_expiry_t" title="k_timer_expiry_t">k_timer_expiry_t</a> <em>expiry_fn</em>, <a class="reference internal" href="#_CPPv214k_timer_stop_t" title="k_timer_stop_t">k_timer_stop_t</a> <em>stop_fn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_timer_initP7k_timer16k_timer_expiry_t14k_timer_stop_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a timer. </p>
<p>This routine initializes a timer, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer. </li>
<li><code class="docutils literal"><span class="pre">expiry_fn</span></code>: Function to invoke each time the timer expires. </li>
<li><code class="docutils literal"><span class="pre">stop_fn</span></code>: Function to invoke if the timer is stopped while running.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_timer_startP7k_timer5s32_t5s32_t">
<span id="k_timer_start__k_timerP.s32_t.s32_t"></span><span class="target" id="d0/d15/group__timer__apis_1gaca94b975b5e98ba6317114ecea3c5d3c"></span>void <code class="descname">k_timer_start</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, s32_t <em>duration</em>, s32_t <em>period</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv213k_timer_startP7k_timer5s32_t5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start a timer. </p>
<p>This routine starts a timer, and resets its status to zero. The timer begins counting down using the specified duration and period values.</p>
<p>Attempting to start a timer that is already running is permitted. The timer’s status is reset to zero and the timer begins counting down using the new duration and period values.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer. </li>
<li><code class="docutils literal"><span class="pre">duration</span></code>: Initial timer duration (in milliseconds). </li>
<li><code class="docutils literal"><span class="pre">period</span></code>: Timer period (in milliseconds).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_timer_stopP7k_timer">
<span id="k_timer_stop__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1ga8d3e3356a10d36570e16f7920e4c8772"></span>void <code class="descname">k_timer_stop</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_timer_stopP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stop a timer. </p>
<p>This routine stops a running timer prematurely. The timer’s stop function, if one exists, is invoked by the caller.</p>
<p>Attempting to stop a timer that is not running is permitted, but has no effect on the timer.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs. The stop handler has to be callable from ISRs if <em>k_timer_stop</em> is to be called from ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218k_timer_status_getP7k_timer">
<span id="k_timer_status_get__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1gab35db987594d92f9cb81b300d7e5c71b"></span>u32_t <code class="descname">k_timer_status_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv218k_timer_status_getP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read timer status. </p>
<p>This routine reads the timer’s status, which indicates the number of times it has expired since its status was last read.</p>
<p>Calling this routine resets the timer’s status to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timer status. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_timer_status_syncP7k_timer">
<span id="k_timer_status_sync__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1ga0d6c2ef573fb2828f33f97a792709fb2"></span>u32_t <code class="descname">k_timer_status_sync</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_timer_status_syncP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Synchronize thread to timer expiration. </p>
<p>This routine blocks the calling thread until the timer’s status is non-zero (indicating that it has expired at least once since it was last examined) or the timer is stopped. If the timer status is already non-zero, or the timer is already stopped, the caller continues without waiting.</p>
<p>Calling this routine resets the timer’s status to zero.</p>
<p>This routine must not be used by interrupt handlers, since they are not allowed to block.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timer status. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_timer_remaining_getP7k_timer">
<span id="k_timer_remaining_get__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1gadeda23e08ae6eb36bda00bcbdfbb8870"></span>s32_t <code class="descname">k_timer_remaining_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_timer_remaining_getP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get time remaining before a timer next expires. </p>
<p>This routine computes the (approximate) time remaining before a running timer next expires. If the timer is not running, it returns zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Remaining time (in milliseconds). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv227_impl_k_timer_remaining_getP7k_timer">
<span id="_impl_k_timer_remaining_get__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1gad0c68f9ed8e447f8330733623bfded3c"></span><em class="property">static</em> s32_t <code class="descname">_impl_k_timer_remaining_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv227_impl_k_timer_remaining_getP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv221k_timer_user_data_setP7k_timerPv">
<span id="k_timer_user_data_set__k_timerP.voidP"></span><span class="target" id="d0/d15/group__timer__apis_1gadba1884961e790dd9c5d567de91cc7e2"></span>void <code class="descname">k_timer_user_data_set</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, void *<em>user_data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_timer_user_data_setP7k_timerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Associate user-specific data with a timer. </p>
<p>This routine records the <em>user_data</em> with the <em>timer</em>, to be retrieved later.</p>
<p>It can be used e.g. in a timer handler shared across multiple subsystems to retrieve data specific to the subsystem this timer is associated with.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer. </li>
<li><code class="docutils literal"><span class="pre">user_data</span></code>: User data to associate with the timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv227_impl_k_timer_user_data_setP7k_timerPv">
<span id="_impl_k_timer_user_data_set__k_timerP.voidP"></span><span class="target" id="d0/d15/group__timer__apis_1ga3a5ab12faff3abf7c2287e49becba601"></span><em class="property">static</em> void <code class="descname">_impl_k_timer_user_data_set</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, void *<em>user_data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv227_impl_k_timer_user_data_setP7k_timerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv221k_timer_user_data_getP7k_timer">
<span id="k_timer_user_data_get__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1ga903751d111fd5254fdc7ac222b41f5c8"></span>void *<code class="descname">k_timer_user_data_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_timer_user_data_getP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the user-specific data from a timer. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The user data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv227_impl_k_timer_user_data_getP7k_timer">
<span id="_impl_k_timer_user_data_get__k_timerP"></span><span class="target" id="d0/d15/group__timer__apis_1gaf47c2181b367089640ff6847fa1ee4a1"></span><em class="property">static</em> void *<code class="descname">_impl_k_timer_user_data_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv227_impl_k_timer_user_data_getP7k_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="memory-slabs">
<h2><a class="toc-backref" href="#contents">Memory Slabs</a><a class="headerlink" href="#memory-slabs" title="Permalink to this headline">¶</a></h2>
<p>Memory slabs enable the dynamic allocation and release of fixed-size
memory blocks.
(See <a class="reference internal" href="../kernel/memory/slabs.html#memory-slabs-v2"><span class="std std-ref">Memory Slabs</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d6/d4a/group__mem__slab__apis"></span><em>group</em> <code class="descname">mem_slab_apis</code></dt>
<dd><p>end defgroup pipe_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_MEM_SLAB_DEFINE">
<span class="target" id="d6/d4a/group__mem__slab__apis_1ga60bc92eee58fcc5f121b8e4d82eaa69e"></span><code class="descname">K_MEM_SLAB_DEFINE</code><span class="sig-paren">(</span>name, slab_block_size, slab_num_blocks, slab_align<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MEM_SLAB_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a memory slab. </p>
<p>The memory slab’s buffer contains <em>slab_num_blocks</em> memory blocks that are <em>slab_block_size</em> bytes long. The buffer is aligned to a <em>slab_align</em> -byte boundary. To ensure that each memory block is similarly aligned to this boundary, <em>slab_block_size</em> must also be a multiple of <em>slab_align</em>.</p>
<p>The memory slab can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mem_slab</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">slab_block_size</span></code>: Size of each memory block (in bytes). </li>
<li><code class="docutils literal"><span class="pre">slab_num_blocks</span></code>: Number memory blocks. </li>
<li><code class="docutils literal"><span class="pre">slab_align</span></code>: Alignment of the memory slab’s buffer (power of 2). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv215k_mem_slab_initP10k_mem_slabPv6size_t5u32_t">
<span id="k_mem_slab_init__k_mem_slabP.voidP.s.u32_t"></span><span class="target" id="d6/d4a/group__mem__slab__apis_1ga931629ce14a1fd2547d3c0732585ed77"></span>void <code class="descname">k_mem_slab_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em>, void *<em>buffer</em>, size_t <em>block_size</em>, u32_t <em>num_blocks</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_mem_slab_initP10k_mem_slabPv6size_t5u32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a memory slab. </p>
<p>Initializes a memory slab, prior to its first use.</p>
<p>The memory slab’s buffer contains <em>slab_num_blocks</em> memory blocks that are <em>slab_block_size</em> bytes long. The buffer must be aligned to an N-byte boundary, where N is a power of 2 larger than 2 (i.e. 4, 8, 16, …). To ensure that each memory block is similarly aligned to this boundary, <em>slab_block_size</em> must also be a multiple of N.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Pointer to buffer used for the memory blocks. </li>
<li><code class="docutils literal"><span class="pre">block_size</span></code>: Size of each memory block (in bytes). </li>
<li><code class="docutils literal"><span class="pre">num_blocks</span></code>: Number of memory blocks.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_mem_slab_allocP10k_mem_slabPPv5s32_t">
<span id="k_mem_slab_alloc__k_mem_slabP.voidPP.s32_t"></span><span class="target" id="d6/d4a/group__mem__slab__apis_1gace62d4b6659920a7194a72dab830fc59"></span>int <code class="descname">k_mem_slab_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em>, void **<em>mem</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216k_mem_slab_allocP10k_mem_slabPPv5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate memory from a memory slab. </p>
<p>This routine allocates a memory block from a memory slab.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">mem</span></code>: Pointer to block address area. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Maximum time to wait for operation to complete (in milliseconds). Use K_NO_WAIT to return without waiting, or K_FOREVER to wait as long as necessary.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Memory allocated. The block address area pointed at by <em>mem</em> is set to the starting address of the memory block. </li>
<li><code class="docutils literal"><span class="pre">-ENOMEM</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_mem_slab_freeP10k_mem_slabPPv">
<span id="k_mem_slab_free__k_mem_slabP.voidPP"></span><span class="target" id="d6/d4a/group__mem__slab__apis_1ga97915aee5a59e19f8b28185eed93aac7"></span>void <code class="descname">k_mem_slab_free</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em>, void **<em>mem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_mem_slab_freeP10k_mem_slabPPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free memory allocated from a memory slab. </p>
<p>This routine releases a previously allocated memory block back to its associated memory slab.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">mem</span></code>: Pointer to block address area (as set by k_mem_slab_alloc()).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223k_mem_slab_num_used_getP10k_mem_slab">
<span id="k_mem_slab_num_used_get__k_mem_slabP"></span><span class="target" id="d6/d4a/group__mem__slab__apis_1ga91b605acf31c0516fd90cac8f19c45a8"></span><em class="property">static</em> u32_t <code class="descname">k_mem_slab_num_used_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv223k_mem_slab_num_used_getP10k_mem_slab" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of used blocks in a memory slab. </p>
<p>This routine gets the number of memory blocks that are currently allocated in <em>slab</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of allocated memory blocks. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223k_mem_slab_num_free_getP10k_mem_slab">
<span id="k_mem_slab_num_free_get__k_mem_slabP"></span><span class="target" id="d6/d4a/group__mem__slab__apis_1gab80556cab9e4f1426f388bcc0166b9e9"></span><em class="property">static</em> u32_t <code class="descname">k_mem_slab_num_free_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv223k_mem_slab_num_free_getP10k_mem_slab" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of unused blocks in a memory slab. </p>
<p>This routine gets the number of memory blocks that are currently unallocated in <em>slab</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of unallocated memory blocks. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="memory-pools">
<h2><a class="toc-backref" href="#contents">Memory Pools</a><a class="headerlink" href="#memory-pools" title="Permalink to this headline">¶</a></h2>
<p>Memory pools enable the dynamic allocation and release of variable-size
memory blocks.
(See <a class="reference internal" href="../kernel/memory/pools.html#memory-pools-v2"><span class="std std-ref">Memory Pools</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="de/d82/group__mem__pool__apis"></span><em>group</em> <code class="descname">mem_pool_apis</code></dt>
<dd><p>end defgroup msgq_apis</p>
<p>end defgroup mem_slab_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_MEM_POOL_DEFINE">
<span class="target" id="de/d82/group__mem__pool__apis_1gaf732f9b3f0ba8b9c0611ba7d8d6fcbdb"></span><code class="descname">K_MEM_POOL_DEFINE</code><span class="sig-paren">(</span>name, minsz, maxsz, nmax, align<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MEM_POOL_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a memory pool. </p>
<p>The memory pool’s buffer contains <em>n_max</em> blocks that are <em>max_size</em> bytes long. The memory pool allows blocks to be repeatedly partitioned into quarters, down to blocks of <em>min_size</em> bytes long. The buffer is aligned to a <em>align</em> -byte boundary.</p>
<p>If the pool is to be accessed outside the module where it is defined, it can be declared via</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mem_pool</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the memory pool. </li>
<li><code class="docutils literal"><span class="pre">minsz</span></code>: Size of the smallest blocks in the pool (in bytes). </li>
<li><code class="docutils literal"><span class="pre">maxsz</span></code>: Size of the largest blocks in the pool (in bytes). </li>
<li><code class="docutils literal"><span class="pre">nmax</span></code>: Number of maximum sized blocks in the pool. </li>
<li><code class="docutils literal"><span class="pre">align</span></code>: Alignment of the pool’s buffer (power of 2). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv216k_mem_pool_allocP10k_mem_poolP11k_mem_block6size_t5s32_t">
<span id="k_mem_pool_alloc__k_mem_poolP.k_mem_blockP.s.s32_t"></span><span class="target" id="de/d82/group__mem__pool__apis_1gae5cdd19fadec1970391c980c2c756784"></span>int <code class="descname">k_mem_pool_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_pool *<em>pool</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, size_t <em>size</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216k_mem_pool_allocP10k_mem_poolP11k_mem_block6size_t5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate memory from a memory pool. </p>
<p>This routine allocates a memory block from a memory pool.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pool</span></code>: Address of the memory pool. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Pointer to block descriptor for the allocated memory. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Amount of memory to allocate (in bytes). </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Maximum time to wait for operation to complete (in milliseconds). Use K_NO_WAIT to return without waiting, or K_FOREVER to wait as long as necessary.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Memory allocated. The <em>data</em> field of the block descriptor is set to the starting address of the memory block. </li>
<li><code class="docutils literal"><span class="pre">-ENOMEM</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_mem_pool_freeP11k_mem_block">
<span id="k_mem_pool_free__k_mem_blockP"></span><span class="target" id="de/d82/group__mem__pool__apis_1ga959cbc76f729ffe5842bf6b2d40c6f8b"></span>void <code class="descname">k_mem_pool_free</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_block *<em>block</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_mem_pool_freeP11k_mem_block" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free memory allocated from a memory pool. </p>
<p>This routine releases a previously allocated memory block back to its memory pool.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">block</span></code>: Pointer to block descriptor for the allocated memory.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="heap-memory-pool">
<h2><a class="toc-backref" href="#contents">Heap Memory Pool</a><a class="headerlink" href="#heap-memory-pool" title="Permalink to this headline">¶</a></h2>
<p>The heap memory pools enable the dynamic allocation and release of memory
in a <code class="xref cpp cpp-func docutils literal"><span class="pre">malloc()</span></code>-like manner.
(See <a class="reference internal" href="../kernel/memory/heap.html#heap-v2"><span class="std std-ref">Heap Memory Pool</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="db/d30/group__heap__apis"></span><em>group</em> <code class="descname">heap_apis</code></dt>
<dd><p>end addtogroup mem_pool_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv28k_malloc6size_t">
<span id="k_malloc__s"></span><span class="target" id="db/d30/group__heap__apis_1gaee4557c0eeb6d2f97fc3715d91742e10"></span>void *<code class="descname">k_malloc</code><span class="sig-paren">(</span>size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv28k_malloc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate memory from heap. </p>
<p>This routine provides traditional malloc() semantics. Memory is allocated from the heap memory pool.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Address of the allocated memory if successful; otherwise NULL. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">size</span></code>: Amount of memory requested (in bytes).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv26k_freePv">
<span id="k_free__voidP"></span><span class="target" id="db/d30/group__heap__apis_1ga79b63cc93b3358cf82d74f40e73b69d5"></span>void <code class="descname">k_free</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv26k_freePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free memory allocated from heap. </p>
<p>This routine provides traditional free() semantics. The memory being returned must have been allocated from the heap memory pool.</p>
<p>If <em>ptr</em> is NULL, no operation is performed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ptr</span></code>: Pointer to previously allocated memory.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28k_calloc6size_t6size_t">
<span id="k_calloc__s.s"></span><span class="target" id="db/d30/group__heap__apis_1ga8e2782f24e6cdc7902fce1950ace696b"></span>void *<code class="descname">k_calloc</code><span class="sig-paren">(</span>size_t <em>nmemb</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv28k_calloc6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate memory from heap, array style. </p>
<p>This routine provides traditional calloc() semantics. Memory is allocated from the heap memory pool and zeroed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Address of the allocated memory if successful; otherwise NULL. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">nmemb</span></code>: Number of elements in the requested array </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Size of each array element (in bytes).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="semaphores">
<h2><a class="toc-backref" href="#contents">Semaphores</a><a class="headerlink" href="#semaphores" title="Permalink to this headline">¶</a></h2>
<p>Semaphores provide traditional counting semaphore capabilities.
(See <a class="reference internal" href="../kernel/synchronization/semaphores.html#semaphores-v2"><span class="std std-ref">Semaphores</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d6/d5e/group__semaphore__apis"></span><em>group</em> <code class="descname">semaphore_apis</code></dt>
<dd><p>end defgroup mutex_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_SEM_DEFINE">
<span class="target" id="d6/d5e/group__semaphore__apis_1ga018a8aa43e02e704deee7b6341502946"></span><code class="descname">K_SEM_DEFINE</code><span class="sig-paren">(</span>name, initial_count, count_limit<span class="sig-paren">)</span><a class="headerlink" href="#c.K_SEM_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a semaphore. </p>
<p>The semaphore can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_sem</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the semaphore. </li>
<li><code class="docutils literal"><span class="pre">initial_count</span></code>: Initial semaphore count. </li>
<li><code class="docutils literal"><span class="pre">count_limit</span></code>: Maximum permitted semaphore count. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv210k_sem_initP5k_semjj">
<span id="k_sem_init__k_semP.unsigned-i.unsigned-i"></span><span class="target" id="d6/d5e/group__semaphore__apis_1gabcc4bc6fb64a1f29a9d5683ea42255ce"></span>void <code class="descname">k_sem_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em>, unsigned int <em>initial_count</em>, unsigned int <em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_sem_initP5k_semjj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a semaphore. </p>
<p>This routine initializes a semaphore object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore. </li>
<li><code class="docutils literal"><span class="pre">initial_count</span></code>: Initial semaphore count. </li>
<li><code class="docutils literal"><span class="pre">limit</span></code>: Maximum permitted semaphore count.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_sem_takeP5k_sem5s32_t">
<span id="k_sem_take__k_semP.s32_t"></span><span class="target" id="d6/d5e/group__semaphore__apis_1gac3a5a529ad5c85ada953449755c71129"></span>int <code class="descname">k_sem_take</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_sem_takeP5k_sem5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Take a semaphore. </p>
<p>This routine takes <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Note</strong></dt>
<dd>When porting code from the nanokernel legacy API to the new API, be careful with the return value of this function. The return value is the reverse of the one of nano_sem_take family of APIs: 0 means success, and non-zero means failure, while the nano_sem_take family returns 1 for success and 0 for failure.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to take the semaphore (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Semaphore taken. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_sem_giveP5k_sem">
<span id="k_sem_give__k_semP"></span><span class="target" id="d6/d5e/group__semaphore__apis_1gab9be3cf1988af2cd6afdace52d497c84"></span>void <code class="descname">k_sem_give</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_sem_giveP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Give a semaphore. </p>
<p>This routine gives <em>sem</em>, unless the semaphore is already at its maximum permitted count.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_sem_resetP5k_sem">
<span id="k_sem_reset__k_semP"></span><span class="target" id="d6/d5e/group__semaphore__apis_1ga1bd12d8d8c1b9c6be9b665d0fefe5562"></span>void <code class="descname">k_sem_reset</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_sem_resetP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset a semaphore’s count to zero. </p>
<p>This routine sets the count of <em>sem</em> to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217_impl_k_sem_resetP5k_sem">
<span id="_impl_k_sem_reset__k_semP"></span><span class="target" id="d6/d5e/group__semaphore__apis_1ga6b550989e91d2887ca1ba830d9dbd181"></span><em class="property">static</em> void <code class="descname">_impl_k_sem_reset</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217_impl_k_sem_resetP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv215k_sem_count_getP5k_sem">
<span id="k_sem_count_get__k_semP"></span><span class="target" id="d6/d5e/group__semaphore__apis_1ga58843b581e170a1811fc38eecbfd01f3"></span>unsigned int <code class="descname">k_sem_count_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_sem_count_getP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a semaphore’s count. </p>
<p>This routine returns the current count of <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current semaphore count. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221_impl_k_sem_count_getP5k_sem">
<span id="_impl_k_sem_count_get__k_semP"></span><span class="target" id="d6/d5e/group__semaphore__apis_1ga6ce2f7f3153314f6f5de76c46c1b72cc"></span><em class="property">static</em> unsigned int <code class="descname">_impl_k_sem_count_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221_impl_k_sem_count_getP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="mutexes">
<h2><a class="toc-backref" href="#contents">Mutexes</a><a class="headerlink" href="#mutexes" title="Permalink to this headline">¶</a></h2>
<p>Mutexes provide traditional reentrant mutex capabilities
with basic priority inheritance.
(See <a class="reference internal" href="../kernel/synchronization/mutexes.html#mutexes-v2"><span class="std std-ref">Mutexes</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d0/dc1/group__mutex__apis"></span><em>group</em> <code class="descname">mutex_apis</code></dt>
<dd><p>end defgroup workqueue_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_MUTEX_DEFINE">
<span class="target" id="d0/dc1/group__mutex__apis_1gab6f3d98fabbdc0918bbc9934d61d63f3"></span><code class="descname">K_MUTEX_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MUTEX_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a mutex. </p>
<p>The mutex can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mutex</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the mutex. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv212k_mutex_initP7k_mutex">
<span id="k_mutex_init__k_mutexP"></span><span class="target" id="d0/dc1/group__mutex__apis_1gaafc58c512a6a388629a09816cbdeebdf"></span>void <code class="descname">k_mutex_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_mutex_initP7k_mutex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a mutex. </p>
<p>This routine initializes a mutex object, prior to its first use.</p>
<p>Upon completion, the mutex is available and does not have an owner.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Address of the mutex.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_mutex_lockP7k_mutex5s32_t">
<span id="k_mutex_lock__k_mutexP.s32_t"></span><span class="target" id="d0/dc1/group__mutex__apis_1ga3c58b6f747db5672d315750e6c98ac85"></span>int <code class="descname">k_mutex_lock</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_mutex_lockP7k_mutex5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock a mutex. </p>
<p>This routine locks <em>mutex</em>. If the mutex is locked by another thread, the calling thread waits until the mutex becomes available or until a timeout occurs.</p>
<p>A thread is permitted to lock a mutex it has already locked. The operation completes immediately and the lock count is increased by 1.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Address of the mutex. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to lock the mutex (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Mutex locked. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_mutex_unlockP7k_mutex">
<span id="k_mutex_unlock__k_mutexP"></span><span class="target" id="d0/dc1/group__mutex__apis_1gabe098971b5dac0a28dd1582e3b8eb0ef"></span>void <code class="descname">k_mutex_unlock</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_mutex_unlockP7k_mutex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock a mutex. </p>
<p>This routine unlocks <em>mutex</em>. The mutex must already be locked by the calling thread.</p>
<p>The mutex cannot be claimed by another thread until it has been unlocked by the calling thread as many times as it was previously locked by that thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Address of the mutex.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="alerts">
<h2><a class="toc-backref" href="#contents">Alerts</a><a class="headerlink" href="#alerts" title="Permalink to this headline">¶</a></h2>
<p>Alerts enable an application to perform asynchronous signaling,
somewhat akin to Unix-style signals.
(See <a class="reference internal" href="../kernel/synchronization/alerts.html#alerts-v2"><span class="std std-ref">Alerts</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d4/d28/group__alert__apis"></span><em>group</em> <code class="descname">alert_apis</code></dt>
<dd><p>end defgroup semaphore_apis</p>
<p>end defgroup alert_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_ALERT_DEFINE">
<span class="target" id="d4/d28/group__alert__apis_1ga168bcb820df2cb1e72c7eeb697322f33"></span><code class="descname">K_ALERT_DEFINE</code><span class="sig-paren">(</span>name, alert_handler, max_num_pending_alerts<span class="sig-paren">)</span><a class="headerlink" href="#c.K_ALERT_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize an alert. </p>
<p>The alert can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_alert</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the alert. </li>
<li><code class="docutils literal"><span class="pre">alert_handler</span></code>: Action to take when alert is sent. Specify either the address of a function to be invoked by the system workqueue thread, K_ALERT_IGNORE (which causes the alert to be ignored), or K_ALERT_DEFAULT (which causes the alert to pend). </li>
<li><code class="docutils literal"><span class="pre">max_num_pending_alerts</span></code>: Maximum number of pending alerts. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv217k_alert_handler_t">
<span id="k_alert_handler_t"></span><span class="target" id="d4/d28/group__alert__apis_1ga93cefa21ba46f6b2c13c3800af3bb961"></span><em class="property">typedef </em><code class="descname">k_alert_handler_t</code><a class="headerlink" href="#_CPPv217k_alert_handler_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Alert handler function type. </p>
<p>An alert’s alert handler function is invoked by the system workqueue when the alert is signaled. The alert handler function is optional, and is only invoked if the alert has been initialized with one.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if alert has been consumed; non-zero if alert should pend. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv212k_alert_initP7k_alert17k_alert_handler_tj">
<span id="k_alert_init__k_alertP.k_alert_handler_t.unsigned-i"></span><span class="target" id="d4/d28/group__alert__apis_1gaf34f53d18d71b9518f337eebbd7ae05b"></span>void <code class="descname">k_alert_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_alert *<em>alert</em>, <a class="reference internal" href="#_CPPv217k_alert_handler_t" title="k_alert_handler_t">k_alert_handler_t</a> <em>handler</em>, unsigned int <em>max_num_pending_alerts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_alert_initP7k_alert17k_alert_handler_tj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize an alert. </p>
<p>This routine initializes an alert object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Action to take when alert is sent. Specify either the address of a function to be invoked by the system workqueue thread, K_ALERT_IGNORE (which causes the alert to be ignored), or K_ALERT_DEFAULT (which causes the alert to pend). </li>
<li><code class="docutils literal"><span class="pre">max_num_pending_alerts</span></code>: Maximum number of pending alerts.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_alert_recvP7k_alert5s32_t">
<span id="k_alert_recv__k_alertP.s32_t"></span><span class="target" id="d4/d28/group__alert__apis_1gab75f477f28414edd6cca768d1e3c83a7"></span>int <code class="descname">k_alert_recv</code><span class="sig-paren">(</span><em class="property">struct</em> k_alert *<em>alert</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_alert_recvP7k_alert5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive an alert. </p>
<p>This routine receives a pending alert for <em>alert</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to receive the alert (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Alert received. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_alert_sendP7k_alert">
<span id="k_alert_send__k_alertP"></span><span class="target" id="d4/d28/group__alert__apis_1gac9e00523e612aa28b834b9e192bc7f96"></span>void <code class="descname">k_alert_send</code><span class="sig-paren">(</span><em class="property">struct</em> k_alert *<em>alert</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_alert_sendP7k_alert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal an alert. </p>
<p>This routine signals <em>alert</em>. The action specified for <em>alert</em> will be taken, which may trigger the execution of an alert handler function and/or cause the alert to pend (assuming the alert has not reached its maximum number of pending alerts).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="fifos">
<h2><a class="toc-backref" href="#contents">Fifos</a><a class="headerlink" href="#fifos" title="Permalink to this headline">¶</a></h2>
<p>Fifos provide traditional first in, first out (FIFO) queuing of data items
of any size.
(See <a class="reference internal" href="../kernel/data_passing/fifos.html#fifos-v2"><span class="std std-ref">Fifos</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d2/dbb/group__fifo__apis"></span><em>group</em> <code class="descname">fifo_apis</code></dt>
<dd><p>end defgroup queue_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.k_fifo_init">
<span class="target" id="d2/dbb/group__fifo__apis_1gaeebf6ef54d4be61e19408f44a734a159"></span><code class="descname">k_fifo_init</code><span class="sig-paren">(</span>fifo<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a fifo. </p>
<p>This routine initializes a fifo object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_cancel_wait">
<span class="target" id="d2/dbb/group__fifo__apis_1gab744080af449e093df8dd4982e013e16"></span><code class="descname">k_fifo_cancel_wait</code><span class="sig-paren">(</span>fifo<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_cancel_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel waiting on a fifo. </p>
<p>This routine causes first thread pending on <em>fifo</em>, if any, to return from k_fifo_get() call with NULL value (as if timeout expired).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_put">
<span class="target" id="d2/dbb/group__fifo__apis_1ga3addb10f86f19e245c23362433d5c913"></span><code class="descname">k_fifo_put</code><span class="sig-paren">(</span>fifo, data<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an element to a fifo. </p>
<p>This routine adds a data item to <em>fifo</em>. A fifo data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_put_list">
<span class="target" id="d2/dbb/group__fifo__apis_1ga1bf5f52290c83e54ba14358cbbb4051b"></span><code class="descname">k_fifo_put_list</code><span class="sig-paren">(</span>fifo, head, tail<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_put_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically add a list of elements to a fifo. </p>
<p>This routine adds a list of data items to <em>fifo</em> in one operation. The data items must be in a singly-linked list, with the first 32 bits each data item pointing to the next data item; the list must be NULL-terminated.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">head</span></code>: Pointer to first node in singly-linked list. </li>
<li><code class="docutils literal"><span class="pre">tail</span></code>: Pointer to last node in singly-linked list.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_put_slist">
<span class="target" id="d2/dbb/group__fifo__apis_1ga4cdc286a7a6f0d43acab63a4846815e7"></span><code class="descname">k_fifo_put_slist</code><span class="sig-paren">(</span>fifo, list<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_put_slist" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically add a list of elements to a fifo. </p>
<p>This routine adds a list of data items to <em>fifo</em> in one operation. The data items must be in a singly-linked list implemented using a sys_slist_t object. Upon completion, the sys_slist_t object is invalid and must be re-initialized via sys_slist_init().</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">list</span></code>: Pointer to sys_slist_t object.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_get">
<span class="target" id="d2/dbb/group__fifo__apis_1ga1e2c480e2124116af97e94e7b4435de6"></span><code class="descname">k_fifo_get</code><span class="sig-paren">(</span>fifo, timeout<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an element from a fifo. </p>
<p>This routine removes a data item from <em>fifo</em> in a “first in, first out” manner. The first 32 bits of the data item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Return</strong></dt>
<dd>Address of the data item if successful; NULL if returned without waiting, or waiting period timed out. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a data item (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_is_empty">
<span class="target" id="d2/dbb/group__fifo__apis_1gab7cec4adc128ed1fd2d194ba6cd8c640"></span><code class="descname">k_fifo_is_empty</code><span class="sig-paren">(</span>fifo<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Query a fifo to see if it has data available. </p>
<p>Note that the data might be already gone by the time this function returns if other threads is also trying to read from the fifo.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>Non-zero if the fifo is empty. </dd>
<dt><strong>Return</strong></dt>
<dd>0 if data is available. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_peek_head">
<span class="target" id="d2/dbb/group__fifo__apis_1ga2e0c8608f095a929740fa94c94a4f389"></span><code class="descname">k_fifo_peek_head</code><span class="sig-paren">(</span>fifo<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_peek_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Peek element at the head of fifo. </p>
<p>Return element from the head of fifo without removing it. A usecase for this is if elements of the fifo are themselves containers. Then on each iteration of processing, a head container will be peeked, and some data processed out of it, and only if the container is empty, it will be completely remove from the fifo.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Head element, or NULL if the fifo is empty. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_fifo_peek_tail">
<span class="target" id="d2/dbb/group__fifo__apis_1gafbe2ce9a6437b886cf149016187ba92f"></span><code class="descname">k_fifo_peek_tail</code><span class="sig-paren">(</span>fifo<span class="sig-paren">)</span><a class="headerlink" href="#c.k_fifo_peek_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Peek element at the tail of fifo. </p>
<p>Return element from the tail of fifo (without removing it). A usecase for this is if elements of the fifo are themselves containers. Then it may be useful to add more data to the last container in fifo.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Tail element, or NULL if fifo is empty. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_FIFO_DEFINE">
<span class="target" id="d2/dbb/group__fifo__apis_1ga230b02a526ecb0ae1598be75cb9a8274"></span><code class="descname">K_FIFO_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span><a class="headerlink" href="#c.K_FIFO_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a fifo. </p>
<p>The fifo can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_fifo</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the fifo. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="lifos">
<h2><a class="toc-backref" href="#contents">Lifos</a><a class="headerlink" href="#lifos" title="Permalink to this headline">¶</a></h2>
<p>Lifos provide traditional last in, first out (LIFO) queuing of data items
of any size.
(See <a class="reference internal" href="../kernel/data_passing/lifos.html#lifos-v2"><span class="std std-ref">Lifos</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d8/d92/group__lifo__apis"></span><em>group</em> <code class="descname">lifo_apis</code></dt>
<dd><p>end defgroup fifo_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.k_lifo_init">
<span class="target" id="d8/d92/group__lifo__apis_1ga69fb19716a9014f7de79f8e524d64a3e"></span><code class="descname">k_lifo_init</code><span class="sig-paren">(</span>lifo<span class="sig-paren">)</span><a class="headerlink" href="#c.k_lifo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a lifo. </p>
<p>This routine initializes a lifo object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: Address of the lifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_lifo_put">
<span class="target" id="d8/d92/group__lifo__apis_1gad662e36b1df8b9013e2dc61f9dfe3a8b"></span><code class="descname">k_lifo_put</code><span class="sig-paren">(</span>lifo, data<span class="sig-paren">)</span><a class="headerlink" href="#c.k_lifo_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an element to a lifo. </p>
<p>This routine adds a data item to <em>lifo</em>. A lifo data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: Address of the lifo. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_lifo_get">
<span class="target" id="d8/d92/group__lifo__apis_1gad5f1775947b07a2a77f667aa9e41db5a"></span><code class="descname">k_lifo_get</code><span class="sig-paren">(</span>lifo, timeout<span class="sig-paren">)</span><a class="headerlink" href="#c.k_lifo_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an element from a lifo. </p>
<p>This routine removes a data item from <em>lifo</em> in a “last in, first out” manner. The first 32 bits of the data item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Return</strong></dt>
<dd>Address of the data item if successful; NULL if returned without waiting, or waiting period timed out. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: Address of the lifo. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a data item (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_LIFO_DEFINE">
<span class="target" id="d8/d92/group__lifo__apis_1gaebd450d4181f22491623ea0aed6ee576"></span><code class="descname">K_LIFO_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span><a class="headerlink" href="#c.K_LIFO_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a lifo. </p>
<p>The lifo can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_lifo</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the fifo. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="stacks">
<h2><a class="toc-backref" href="#contents">Stacks</a><a class="headerlink" href="#stacks" title="Permalink to this headline">¶</a></h2>
<p>Stacks provide traditional last in, first out (LIFO) queuing of 32-bit
data items.
(See <a class="reference internal" href="../kernel/data_passing/stacks.html#stacks-v2"><span class="std std-ref">Stacks</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="dc/d17/group__stack__apis"></span><em>group</em> <code class="descname">stack_apis</code></dt>
<dd><p>end defgroup lifo_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_STACK_DEFINE">
<span class="target" id="dc/d17/group__stack__apis_1ga8c9ca77e5de3c9757dcd4ecb55797835"></span><code class="descname">K_STACK_DEFINE</code><span class="sig-paren">(</span>name, stack_num_entries<span class="sig-paren">)</span><a class="headerlink" href="#c.K_STACK_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a stack. </p>
<p>The stack can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_stack</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the stack. </li>
<li><code class="docutils literal"><span class="pre">stack_num_entries</span></code>: Maximum number of values that can be stacked. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv212k_stack_initP7k_stackP5u32_tj">
<span id="k_stack_init__k_stackP.u32_tP.unsigned-i"></span><span class="target" id="dc/d17/group__stack__apis_1ga7ead57a9175efc92061afdff59d218d4"></span>void <code class="descname">k_stack_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, u32_t *<em>buffer</em>, unsigned int <em>num_entries</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_stack_initP7k_stackP5u32_tj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a stack. </p>
<p>This routine initializes a stack object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Address of the stack. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of array used to hold stacked values. </li>
<li><code class="docutils literal"><span class="pre">num_entries</span></code>: Maximum number of values that can be stacked.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_stack_pushP7k_stack5u32_t">
<span id="k_stack_push__k_stackP.u32_t"></span><span class="target" id="dc/d17/group__stack__apis_1ga2cee1e11cc3b4bee69139bbf89a5adad"></span>void <code class="descname">k_stack_push</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, u32_t <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_stack_pushP7k_stack5u32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push an element onto a stack. </p>
<p>This routine adds a 32-bit value <em>data</em> to <em>stack</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Address of the stack. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Value to push onto the stack.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_stack_popP7k_stackP5u32_t5s32_t">
<span id="k_stack_pop__k_stackP.u32_tP.s32_t"></span><span class="target" id="dc/d17/group__stack__apis_1ga2064737a0646e42d1a547b52ea72e936"></span>int <code class="descname">k_stack_pop</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, u32_t *<em>data</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_stack_popP7k_stackP5u32_t5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pop an element from a stack. </p>
<p>This routine removes a 32-bit value from <em>stack</em> in a “last in, first out” manner and stores the value in <em>data</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Address of the stack. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of area to hold the value popped from the stack. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a value (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Element popped from stack. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="queues">
<h2><a class="toc-backref" href="#contents">Queues</a><a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h2>
<dl class="group">
<dt>
<span class="target" id="d3/d68/group__queue__apis"></span><em>group</em> <code class="descname">queue_apis</code></dt>
<dd><p>end addtogroup clock_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_QUEUE_DEFINE">
<span class="target" id="d3/d68/group__queue__apis_1gacd0bc309f0147d4669f65fafa87e0e70"></span><code class="descname">K_QUEUE_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span><a class="headerlink" href="#c.K_QUEUE_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a queue. </p>
<p>The queue can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_queue</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the queue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv212k_queue_initP7k_queue">
<span id="k_queue_init__k_queueP"></span><span class="target" id="d3/d68/group__queue__apis_1ga0236222d42768c2bf00942f328146c21"></span>void <code class="descname">k_queue_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_queue_initP7k_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a queue. </p>
<p>This routine initializes a queue object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_queue_cancel_waitP7k_queue">
<span id="k_queue_cancel_wait__k_queueP"></span><span class="target" id="d3/d68/group__queue__apis_1ga7c39d86cc6509f59ff9223cac3ea5071"></span>void <code class="descname">k_queue_cancel_wait</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_queue_cancel_waitP7k_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel waiting on a queue. </p>
<p>This routine causes first thread pending on <em>queue</em>, if any, to return from k_queue_get() call with NULL value (as if timeout expired).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_queue_appendP7k_queuePv">
<span id="k_queue_append__k_queueP.voidP"></span><span class="target" id="d3/d68/group__queue__apis_1gaa84522a5ace6e7f8ba61033baca6972f"></span>void <code class="descname">k_queue_append</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_queue_appendP7k_queuePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append an element to the end of a queue. </p>
<p>This routine appends a data item to <em>queue</em>. A queue data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_queue_prependP7k_queuePv">
<span id="k_queue_prepend__k_queueP.voidP"></span><span class="target" id="d3/d68/group__queue__apis_1ga8ce013d8a037d4be5078797e0050e9c6"></span>void <code class="descname">k_queue_prepend</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_queue_prependP7k_queuePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prepend an element to a queue. </p>
<p>This routine prepends a data item to <em>queue</em>. A queue data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_queue_insertP7k_queuePvPv">
<span id="k_queue_insert__k_queueP.voidP.voidP"></span><span class="target" id="d3/d68/group__queue__apis_1gad47336f27e433a52600a3b67ab89556a"></span>void <code class="descname">k_queue_insert</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, void *<em>prev</em>, void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_queue_insertP7k_queuePvPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inserts an element to a queue. </p>
<p>This routine inserts a data item to <em>queue</em> after previous item. A queue data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">prev</span></code>: Address of the previous data item. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_queue_append_listP7k_queuePvPv">
<span id="k_queue_append_list__k_queueP.voidP.voidP"></span><span class="target" id="d3/d68/group__queue__apis_1ga5f8b78166ec64c8ab24053738eb0daea"></span>void <code class="descname">k_queue_append_list</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, void *<em>head</em>, void *<em>tail</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_queue_append_listP7k_queuePvPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically append a list of elements to a queue. </p>
<p>This routine adds a list of data items to <em>queue</em> in one operation. The data items must be in a singly-linked list, with the first 32 bits in each data item pointing to the next data item; the list must be NULL-terminated.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">head</span></code>: Pointer to first node in singly-linked list. </li>
<li><code class="docutils literal"><span class="pre">tail</span></code>: Pointer to last node in singly-linked list.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_queue_merge_slistP7k_queueP11sys_slist_t">
<span id="k_queue_merge_slist__k_queueP.sys_slist_tP"></span><span class="target" id="d3/d68/group__queue__apis_1ga49a670c9e6eaffebee96cf8223fab99f"></span>void <code class="descname">k_queue_merge_slist</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, sys_slist_t *<em>list</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_queue_merge_slistP7k_queueP11sys_slist_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically add a list of elements to a queue. </p>
<p>This routine adds a list of data items to <em>queue</em> in one operation. The data items must be in a singly-linked list implemented using a sys_slist_t object. Upon completion, the original list is empty.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">list</span></code>: Pointer to sys_slist_t object.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_queue_getP7k_queue5s32_t">
<span id="k_queue_get__k_queueP.s32_t"></span><span class="target" id="d3/d68/group__queue__apis_1ga7106c8059aed92ea8a1e62378e0910cc"></span>void *<code class="descname">k_queue_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_queue_getP7k_queue5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get an element from a queue. </p>
<p>This routine removes first data item from <em>queue</em>. The first 32 bits of the data item are reserved for the kernel’s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Return</strong></dt>
<dd>Address of the data item if successful; NULL if returned without waiting, or waiting period timed out. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a data item (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_queue_removeP7k_queuePv">
<span id="k_queue_remove__k_queueP.voidP"></span><span class="target" id="d3/d68/group__queue__apis_1gae51c9c6308915a31a371d19873360ca1"></span><em class="property">static</em> bool <code class="descname">k_queue_remove</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em>, void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_queue_removeP7k_queuePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove an element from a queue. </p>
<p>This routine removes data item from <em>queue</em>. The first 32 bits of the data item are reserved for the kernel’s use. Removing elements from k_queue rely on sys_slist_find_and_remove which is not a constant time operation.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs</dd>
<dt><strong>Return</strong></dt>
<dd>true if data item was removed </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_queue_is_emptyP7k_queue">
<span id="k_queue_is_empty__k_queueP"></span><span class="target" id="d3/d68/group__queue__apis_1gad74fa668005681ae8c3ce29cae0bfa1a"></span><em class="property">static</em> int <code class="descname">k_queue_is_empty</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216k_queue_is_emptyP7k_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Query a queue to see if it has data available. </p>
<p>Note that the data might be already gone by the time this function returns if other threads are also trying to read from the queue.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>Non-zero if the queue is empty. </dd>
<dt><strong>Return</strong></dt>
<dd>0 if data is available. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217k_queue_peek_headP7k_queue">
<span id="k_queue_peek_head__k_queueP"></span><span class="target" id="d3/d68/group__queue__apis_1gaf2913d8497adf3de441588187095686e"></span><em class="property">static</em> void *<code class="descname">k_queue_peek_head</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217k_queue_peek_headP7k_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Peek element at the head of queue. </p>
<p>Return element from the head of queue without removing it.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Head element, or NULL if queue is empty. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217k_queue_peek_tailP7k_queue">
<span id="k_queue_peek_tail__k_queueP"></span><span class="target" id="d3/d68/group__queue__apis_1ga94460f3169ac45f13517f6a1afae35d6"></span><em class="property">static</em> void *<code class="descname">k_queue_peek_tail</code><span class="sig-paren">(</span><em class="property">struct</em> k_queue *<em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217k_queue_peek_tailP7k_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Peek element at the tail of queue. </p>
<p>Return element from the tail of queue without removing it.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Tail element, or NULL if queue is empty. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: Address of the queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="message-queues">
<h2><a class="toc-backref" href="#contents">Message Queues</a><a class="headerlink" href="#message-queues" title="Permalink to this headline">¶</a></h2>
<p>Message queues provide a simple message queuing mechanism
for fixed-size data items.
(See <a class="reference internal" href="../kernel/data_passing/message_queues.html#message-queues-v2"><span class="std std-ref">Message Queues</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d1/d90/group__msgq__apis"></span><em>group</em> <code class="descname">msgq_apis</code></dt>
<dd><p>end addtogroup alert_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_MSGQ_DEFINE">
<span class="target" id="d1/d90/group__msgq__apis_1ga95ef93002766901511d09c8cd8f8293b"></span><code class="descname">K_MSGQ_DEFINE</code><span class="sig-paren">(</span>q_name, q_msg_size, q_max_msgs, q_align<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MSGQ_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a message queue. </p>
<p>The message queue’s ring buffer contains space for <em>q_max_msgs</em> messages, each of which is <em>q_msg_size</em> bytes long. The buffer is aligned to a <em>q_align</em> -byte boundary, which must be a power of 2. To ensure that each message is similarly aligned to this boundary, <em>q_msg_size</em> must also be a multiple of <em>q_align</em>.</p>
<p>The message queue can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_msgq</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q_name</span></code>: Name of the message queue. </li>
<li><code class="docutils literal"><span class="pre">q_msg_size</span></code>: Message size (in bytes). </li>
<li><code class="docutils literal"><span class="pre">q_max_msgs</span></code>: Maximum number of messages that can be queued. </li>
<li><code class="docutils literal"><span class="pre">q_align</span></code>: Alignment of the message queue’s ring buffer. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv211k_msgq_initP6k_msgqPc6size_t5u32_t">
<span id="k_msgq_init__k_msgqP.cP.s.u32_t"></span><span class="target" id="d1/d90/group__msgq__apis_1gabecebf8dcfc6902eddaf84b6bfaeb1e4"></span>void <code class="descname">k_msgq_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em>, char *<em>buffer</em>, size_t <em>msg_size</em>, u32_t <em>max_msgs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_msgq_initP6k_msgqPc6size_t5u32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a message queue. </p>
<p>This routine initializes a message queue object, prior to its first use.</p>
<p>The message queue’s ring buffer must contain space for <em>max_msgs</em> messages, each of which is <em>msg_size</em> bytes long. The buffer must be aligned to an N-byte boundary, where N is a power of 2 (i.e. 1, 2, 4, …). To ensure that each message is similarly aligned to this boundary, <em>q_msg_size</em> must also be a multiple of N.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Pointer to ring buffer that holds queued messages. </li>
<li><code class="docutils literal"><span class="pre">msg_size</span></code>: Message size (in bytes). </li>
<li><code class="docutils literal"><span class="pre">max_msgs</span></code>: Maximum number of messages that can be queued.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_msgq_putP6k_msgqPv5s32_t">
<span id="k_msgq_put__k_msgqP.voidP.s32_t"></span><span class="target" id="d1/d90/group__msgq__apis_1ga98c8a1183c6388b060a9893edc662ed2"></span>int <code class="descname">k_msgq_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em>, void *<em>data</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_msgq_putP6k_msgqPv5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a message to a message queue. </p>
<p>This routine sends a message to message queue <em>q</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Pointer to the message. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to add the message (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message sent. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting or queue purged. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_msgq_getP6k_msgqPv5s32_t">
<span id="k_msgq_get__k_msgqP.voidP.s32_t"></span><span class="target" id="d1/d90/group__msgq__apis_1ga72f9e14259425bfe28c0e6fe373a5128"></span>int <code class="descname">k_msgq_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em>, void *<em>data</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_msgq_getP6k_msgqPv5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive a message from a message queue. </p>
<p>This routine receives a message from message queue <em>q</em> in a “first in,
first out” manner.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of area to hold the received message. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to receive the message (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message received. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_msgq_purgeP6k_msgq">
<span id="k_msgq_purge__k_msgqP"></span><span class="target" id="d1/d90/group__msgq__apis_1ga128de935d95fdb686f1df5823c890c9e"></span>void <code class="descname">k_msgq_purge</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212k_msgq_purgeP6k_msgq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Purge a message queue. </p>
<p>This routine discards all unreceived messages in a message queue’s ring buffer. Any threads that are blocked waiting to send a message to the message queue are unblocked and see an -ENOMSG error code.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_msgq_num_free_getP6k_msgq">
<span id="k_msgq_num_free_get__k_msgqP"></span><span class="target" id="d1/d90/group__msgq__apis_1gad62e51d4779b2b5c827c5b97b64684ec"></span>u32_t <code class="descname">k_msgq_num_free_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_msgq_num_free_getP6k_msgq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the amount of free space in a message queue. </p>
<p>This routine returns the number of unused entries in a message queue’s ring buffer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of unused ring buffer entries. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225_impl_k_msgq_num_free_getP6k_msgq">
<span id="_impl_k_msgq_num_free_get__k_msgqP"></span><span class="target" id="d1/d90/group__msgq__apis_1gae796aea614d324d1109c609030f0c2e6"></span><em class="property">static</em> u32_t <code class="descname">_impl_k_msgq_num_free_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv225_impl_k_msgq_num_free_getP6k_msgq" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv219k_msgq_num_used_getP6k_msgq">
<span id="k_msgq_num_used_get__k_msgqP"></span><span class="target" id="d1/d90/group__msgq__apis_1gae279b2e63ca0139e8c42ee477a30f612"></span>u32_t <code class="descname">k_msgq_num_used_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_msgq_num_used_getP6k_msgq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of messages in a message queue. </p>
<p>This routine returns the number of messages in a message queue’s ring buffer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of messages. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225_impl_k_msgq_num_used_getP6k_msgq">
<span id="_impl_k_msgq_num_used_get__k_msgqP"></span><span class="target" id="d1/d90/group__msgq__apis_1gad5cfacc5c10d40fb783903eab36a6f75"></span><em class="property">static</em> u32_t <code class="descname">_impl_k_msgq_num_used_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv225_impl_k_msgq_num_used_getP6k_msgq" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="mailboxes">
<h2><a class="toc-backref" href="#contents">Mailboxes</a><a class="headerlink" href="#mailboxes" title="Permalink to this headline">¶</a></h2>
<p>Mailboxes provide an enhanced message queuing mechanism
for variable-size messages.
(See <a class="reference internal" href="../kernel/data_passing/mailboxes.html#mailboxes-v2"><span class="std std-ref">Mailboxes</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d7/df7/group__mailbox__apis"></span><em>group</em> <code class="descname">mailbox_apis</code></dt>
<dd><p>end defgroup mem_pool_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_MBOX_DEFINE">
<span class="target" id="d7/df7/group__mailbox__apis_1gab55cba898db47113a06641c01f3e3714"></span><code class="descname">K_MBOX_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MBOX_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a mailbox. </p>
<p>The mailbox is to be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mbox</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the mailbox. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv211k_mbox_initP6k_mbox">
<span id="k_mbox_init__k_mboxP"></span><span class="target" id="d7/df7/group__mailbox__apis_1ga686f20c199a9e971822d8279d175d8c2"></span>void <code class="descname">k_mbox_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_mbox_initP6k_mbox" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a mailbox. </p>
<p>This routine initializes a mailbox object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_mbox_putP6k_mboxP10k_mbox_msg5s32_t">
<span id="k_mbox_put__k_mboxP.k_mbox_msgP.s32_t"></span><span class="target" id="d7/df7/group__mailbox__apis_1ga532992bccd704e2a3b9cdaf6c654ca24"></span>int <code class="descname">k_mbox_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_mbox_msg *<em>tx_msg</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_mbox_putP6k_mboxP10k_mbox_msg5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a mailbox message in a synchronous manner. </p>
<p>This routine sends a message to <em>mbox</em> and waits for a receiver to both receive and process it. The message data may be in a buffer, in a memory pool block, or non-existent (i.e. an empty message).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox. </li>
<li><code class="docutils literal"><span class="pre">tx_msg</span></code>: Address of the transmit message descriptor. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period for the message to be received (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER. Once the message has been received, this routine waits as long as necessary for the message to be completely processed.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message sent. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_mbox_async_putP6k_mboxP10k_mbox_msgP5k_sem">
<span id="k_mbox_async_put__k_mboxP.k_mbox_msgP.k_semP"></span><span class="target" id="d7/df7/group__mailbox__apis_1gadd60f7b760371c0a141a1e4da253a0f0"></span>void <code class="descname">k_mbox_async_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_mbox_msg *<em>tx_msg</em>, <em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216k_mbox_async_putP6k_mboxP10k_mbox_msgP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a mailbox message in an asynchronous manner. </p>
<p>This routine sends a message to <em>mbox</em> without waiting for a receiver to process it. The message data may be in a buffer, in a memory pool block, or non-existent (i.e. an empty message). Optionally, the semaphore <em>sem</em> will be given when the message has been both received and completely processed by the receiver.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox. </li>
<li><code class="docutils literal"><span class="pre">tx_msg</span></code>: Address of the transmit message descriptor. </li>
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of a semaphore, or NULL if none is needed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_mbox_getP6k_mboxP10k_mbox_msgPv5s32_t">
<span id="k_mbox_get__k_mboxP.k_mbox_msgP.voidP.s32_t"></span><span class="target" id="d7/df7/group__mailbox__apis_1gab65357913942350acf9b70d54cabba6e"></span>int <code class="descname">k_mbox_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_mbox_msg *<em>rx_msg</em>, void *<em>buffer</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_mbox_getP6k_mboxP10k_mbox_msgPv5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive a mailbox message. </p>
<p>This routine receives a message from <em>mbox</em>, then optionally retrieves its data and disposes of the message.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox. </li>
<li><code class="docutils literal"><span class="pre">rx_msg</span></code>: Address of the receive message descriptor. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of the buffer to receive data, or NULL to defer data retrieval and message disposal until later. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period for a message to be received (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message received. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_mbox_data_getP10k_mbox_msgPv">
<span id="k_mbox_data_get__k_mbox_msgP.voidP"></span><span class="target" id="d7/df7/group__mailbox__apis_1ga3d19e648e67f109609259543c9a01d6e"></span>void <code class="descname">k_mbox_data_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox_msg *<em>rx_msg</em>, void *<em>buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_mbox_data_getP10k_mbox_msgPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve mailbox message data into a buffer. </p>
<p>This routine completes the processing of a received message by retrieving its data into a buffer, then disposing of the message.</p>
<p>Alternatively, this routine can be used to dispose of a received message without retrieving its data.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">rx_msg</span></code>: Address of the receive message descriptor. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of the buffer to receive data, or NULL to discard the data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_mbox_data_block_getP10k_mbox_msgP10k_mem_poolP11k_mem_block5s32_t">
<span id="k_mbox_data_block_get__k_mbox_msgP.k_mem_poolP.k_mem_blockP.s32_t"></span><span class="target" id="d7/df7/group__mailbox__apis_1ga816c5edc9d39e7a5daf48f576b66506b"></span>int <code class="descname">k_mbox_data_block_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox_msg *<em>rx_msg</em>, <em class="property">struct</em> k_mem_pool *<em>pool</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_mbox_data_block_getP10k_mbox_msgP10k_mem_poolP11k_mem_block5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve mailbox message data into a memory pool block. </p>
<p>This routine completes the processing of a received message by retrieving its data into a memory pool block, then disposing of the message. The memory pool block that results from successful retrieval must be returned to the pool once the data has been processed, even in cases where zero bytes of data are retrieved.</p>
<p>Alternatively, this routine can be used to dispose of a received message without retrieving its data. In this case there is no need to return a memory pool block to the pool.</p>
<p>This routine allocates a new memory pool block for the data only if the data is not already in one. If a new block cannot be allocated, the routine returns a failure code and the received message is left unchanged. This permits the caller to reattempt data retrieval at a later time or to dispose of the received message without retrieving its data.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">rx_msg</span></code>: Address of a receive message descriptor. </li>
<li><code class="docutils literal"><span class="pre">pool</span></code>: Address of memory pool, or NULL to discard data. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Address of the area to hold memory pool block info. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to wait for a memory pool block (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Data retrieved. </li>
<li><code class="docutils literal"><span class="pre">-ENOMEM</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="pipes">
<h2><a class="toc-backref" href="#contents">Pipes</a><a class="headerlink" href="#pipes" title="Permalink to this headline">¶</a></h2>
<p>Pipes provide a traditional anonymous pipe mechanism for sending
variable-size chunks of data, in whole or in part.
(See <a class="reference internal" href="../kernel/data_passing/pipes.html#pipes-v2"><span class="std std-ref">Pipes</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="da/d0d/group__pipe__apis"></span><em>group</em> <code class="descname">pipe_apis</code></dt>
<dd><p>end defgroup mailbox_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_PIPE_DEFINE">
<span class="target" id="da/d0d/group__pipe__apis_1gac2256aa00c59e78199be9bdefd61aa52"></span><code class="descname">K_PIPE_DEFINE</code><span class="sig-paren">(</span>name, pipe_buffer_size, pipe_align<span class="sig-paren">)</span><a class="headerlink" href="#c.K_PIPE_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a pipe. </p>
<p>The pipe can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_pipe</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the pipe. </li>
<li><code class="docutils literal"><span class="pre">pipe_buffer_size</span></code>: Size of the pipe’s ring buffer (in bytes), or zero if no ring buffer is used. </li>
<li><code class="docutils literal"><span class="pre">pipe_align</span></code>: Alignment of the pipe’s ring buffer (power of 2). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv211k_pipe_initP6k_pipePh6size_t">
<span id="k_pipe_init__k_pipeP.unsigned-cP.s"></span><span class="target" id="da/d0d/group__pipe__apis_1gae9e807fb63bb7186b87015664f2c762d"></span>void <code class="descname">k_pipe_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, unsigned char *<em>buffer</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_pipe_initP6k_pipePh6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a pipe. </p>
<p>This routine initializes a pipe object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of the pipe’s ring buffer, or NULL if no ring buffer is used. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Size of the pipe’s ring buffer (in bytes), or zero if no ring buffer is used.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_pipe_putP6k_pipePv6size_tP6size_t6size_t5s32_t">
<span id="k_pipe_put__k_pipeP.voidP.s.sP.s.s32_t"></span><span class="target" id="da/d0d/group__pipe__apis_1ga0256eb6e846db64f6e6d0935e9af08d8"></span>int <code class="descname">k_pipe_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, void *<em>data</em>, size_t <em>bytes_to_write</em>, size_t *<em>bytes_written</em>, size_t <em>min_xfer</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_pipe_putP6k_pipePv6size_tP6size_t6size_t5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write data to a pipe. </p>
<p>This routine writes up to <em>bytes_to_write</em> bytes of data to <em>pipe</em>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of data to write. </li>
<li><code class="docutils literal"><span class="pre">bytes_to_write</span></code>: Size of data (in bytes). </li>
<li><code class="docutils literal"><span class="pre">bytes_written</span></code>: Address of area to hold the number of bytes written. </li>
<li><code class="docutils literal"><span class="pre">min_xfer</span></code>: Minimum number of bytes to write. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to wait for the data to be written (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: At least <em>min_xfer</em> bytes of data were written. </li>
<li><code class="docutils literal"><span class="pre">-EIO</span></code>: Returned without waiting; zero data bytes were written. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out; between zero and <em>min_xfer</em> minus one data bytes were written. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_pipe_getP6k_pipePv6size_tP6size_t6size_t5s32_t">
<span id="k_pipe_get__k_pipeP.voidP.s.sP.s.s32_t"></span><span class="target" id="da/d0d/group__pipe__apis_1ga736d682f4b4cfff4ccb4fa47000091be"></span>int <code class="descname">k_pipe_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, void *<em>data</em>, size_t <em>bytes_to_read</em>, size_t *<em>bytes_read</em>, size_t <em>min_xfer</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210k_pipe_getP6k_pipePv6size_tP6size_t6size_t5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read data from a pipe. </p>
<p>This routine reads up to <em>bytes_to_read</em> bytes of data from <em>pipe</em>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address to place the data read from pipe. </li>
<li><code class="docutils literal"><span class="pre">bytes_to_read</span></code>: Maximum number of data bytes to read. </li>
<li><code class="docutils literal"><span class="pre">bytes_read</span></code>: Address of area to hold the number of bytes read. </li>
<li><code class="docutils literal"><span class="pre">min_xfer</span></code>: Minimum number of data bytes to read. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to wait for the data to be read (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: At least <em>min_xfer</em> bytes of data were read. </li>
<li><code class="docutils literal"><span class="pre">-EIO</span></code>: Returned without waiting; zero data bytes were read. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out; between zero and <em>min_xfer</em> minus one data bytes were read. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_pipe_block_putP6k_pipeP11k_mem_block6size_tP5k_sem">
<span id="k_pipe_block_put__k_pipeP.k_mem_blockP.s.k_semP"></span><span class="target" id="da/d0d/group__pipe__apis_1ga48b800f700f0384a8b2b0260bc3b14da"></span>void <code class="descname">k_pipe_block_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, size_t <em>size</em>, <em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216k_pipe_block_putP6k_pipeP11k_mem_block6size_tP5k_sem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write memory block to a pipe. </p>
<p>This routine writes the data contained in a memory block to <em>pipe</em>. Once all of the data in the block has been written to the pipe, it will free the memory block <em>block</em> and give the semaphore <em>sem</em> (if specified).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Memory block containing data to send </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Number of data bytes in memory block to send </li>
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore to signal upon completion (else NULL)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="asynchronous-polling">
<h2><a class="toc-backref" href="#contents">Asynchronous Polling</a><a class="headerlink" href="#asynchronous-polling" title="Permalink to this headline">¶</a></h2>
<dl class="group">
<dt>
<span class="target" id="db/d60/group__poll__apis"></span><em>group</em> <code class="descname">poll_apis</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.K_POLL_TYPE_IGNORE">
<span class="target" id="db/d60/group__poll__apis_1gafd5d801eb9e9cf6097b2c08b4933998e"></span><code class="descname">K_POLL_TYPE_IGNORE</code><a class="headerlink" href="#c.K_POLL_TYPE_IGNORE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_TYPE_SIGNAL">
<span class="target" id="db/d60/group__poll__apis_1ga144d8eb34d85f6053e454410a10bf56a"></span><code class="descname">K_POLL_TYPE_SIGNAL</code><a class="headerlink" href="#c.K_POLL_TYPE_SIGNAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_TYPE_SEM_AVAILABLE">
<span class="target" id="db/d60/group__poll__apis_1ga0fd7605bdffd43dff7480a90a603ffde"></span><code class="descname">K_POLL_TYPE_SEM_AVAILABLE</code><a class="headerlink" href="#c.K_POLL_TYPE_SEM_AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_TYPE_DATA_AVAILABLE">
<span class="target" id="db/d60/group__poll__apis_1ga58d656f73f031a39b8a936133fe5504f"></span><code class="descname">K_POLL_TYPE_DATA_AVAILABLE</code><a class="headerlink" href="#c.K_POLL_TYPE_DATA_AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_TYPE_FIFO_DATA_AVAILABLE">
<span class="target" id="db/d60/group__poll__apis_1ga71734fee18c523cf70276260118afb91"></span><code class="descname">K_POLL_TYPE_FIFO_DATA_AVAILABLE</code><a class="headerlink" href="#c.K_POLL_TYPE_FIFO_DATA_AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_STATE_NOT_READY">
<span class="target" id="db/d60/group__poll__apis_1ga522822c5e06a89b22ce4dcefd10c66aa"></span><code class="descname">K_POLL_STATE_NOT_READY</code><a class="headerlink" href="#c.K_POLL_STATE_NOT_READY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_STATE_SIGNALED">
<span class="target" id="db/d60/group__poll__apis_1ga478aae7fe4fb5c7b7c76ed216c22a7f1"></span><code class="descname">K_POLL_STATE_SIGNALED</code><a class="headerlink" href="#c.K_POLL_STATE_SIGNALED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_STATE_SEM_AVAILABLE">
<span class="target" id="db/d60/group__poll__apis_1gae9e3eefd5a29a538d22f53592578bb37"></span><code class="descname">K_POLL_STATE_SEM_AVAILABLE</code><a class="headerlink" href="#c.K_POLL_STATE_SEM_AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_STATE_DATA_AVAILABLE">
<span class="target" id="db/d60/group__poll__apis_1gac166d9919d591bace163c5211e7b41f4"></span><code class="descname">K_POLL_STATE_DATA_AVAILABLE</code><a class="headerlink" href="#c.K_POLL_STATE_DATA_AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_STATE_FIFO_DATA_AVAILABLE">
<span class="target" id="db/d60/group__poll__apis_1gabd5ac3341698534f39ded718079d6168"></span><code class="descname">K_POLL_STATE_FIFO_DATA_AVAILABLE</code><a class="headerlink" href="#c.K_POLL_STATE_FIFO_DATA_AVAILABLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_SIGNAL_INITIALIZER">
<span class="target" id="db/d60/group__poll__apis_1ga6d6321e189afca73a276cd671ec531ae"></span><code class="descname">K_POLL_SIGNAL_INITIALIZER</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span><a class="headerlink" href="#c.K_POLL_SIGNAL_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_EVENT_INITIALIZER">
<span class="target" id="db/d60/group__poll__apis_1ga8c60579cbafb7b1f770e7a1731d96089"></span><code class="descname">K_POLL_EVENT_INITIALIZER</code><span class="sig-paren">(</span>event_type, event_mode, event_obj<span class="sig-paren">)</span><a class="headerlink" href="#c.K_POLL_EVENT_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_POLL_EVENT_STATIC_INITIALIZER">
<span class="target" id="db/d60/group__poll__apis_1gad5f1949ca70457debfccaa82fa3ed129"></span><code class="descname">K_POLL_EVENT_STATIC_INITIALIZER</code><span class="sig-paren">(</span>event_type, event_mode, event_obj, event_tag<span class="sig-paren">)</span><a class="headerlink" href="#c.K_POLL_EVENT_STATIC_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="type">
<dt id="_CPPv2N9poll_apis12k_poll_modesE">
<span id="poll_apis::k_poll_modes"></span><span class="target" id="db/d60/group__poll__apis_1ga36d7978872a83191dd3cc16d62165add"></span><em class="property">enum </em><code class="descname">k_poll_modes</code><a class="headerlink" href="#_CPPv2N9poll_apis12k_poll_modesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv2N9poll_apis23K_POLL_MODE_NOTIFY_ONLYE">
<span class="target" id="db/d60/group__poll__apis_ga36d7978872a83191dd3cc16d62165add_1gga36d7978872a83191dd3cc16d62165adda22874743e2f6b0f1fd55c5375732b681"></span><code class="descname">K_POLL_MODE_NOTIFY_ONLY</code> = 0<a class="headerlink" href="#_CPPv2N9poll_apis23K_POLL_MODE_NOTIFY_ONLYE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv2N9poll_apis16K_POLL_NUM_MODESE">
<span class="target" id="db/d60/group__poll__apis_ga36d7978872a83191dd3cc16d62165add_1gga36d7978872a83191dd3cc16d62165adda71e08944b3e944c28056f9a5fbfb018c"></span><code class="descname">K_POLL_NUM_MODES</code><a class="headerlink" href="#_CPPv2N9poll_apis16K_POLL_NUM_MODESE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv217k_poll_event_initP12k_poll_event5u32_tiPv">
<span id="k_poll_event_init__k_poll_eventP.u32_t.i.voidP"></span><span class="target" id="db/d60/group__poll__apis_1ga57be222391f89e8db753c3d8bfcef11e"></span>void <code class="descname">k_poll_event_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_poll_event *<em>event</em>, u32_t <em>type</em>, int <em>mode</em>, void *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217k_poll_event_initP12k_poll_event5u32_tiPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize one struct k_poll_event instance. </p>
<p>After this routine is called on a poll event, the event it ready to be placed in an event array to be passed to k_poll().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">event</span></code>: The event to initialize. </li>
<li><code class="docutils literal"><span class="pre">type</span></code>: A bitfield of the types of event, from the K_POLL_TYPE_xxx values. Only values that apply to the same object being polled can be used together. Choosing K_POLL_TYPE_IGNORE disables the event. </li>
<li><code class="docutils literal"><span class="pre">mode</span></code>: Future. Use K_POLL_MODE_NOTIFY_ONLY. </li>
<li><code class="docutils literal"><span class="pre">obj</span></code>: Kernel object or poll signal.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv26k_pollP12k_poll_eventi5s32_t">
<span id="k_poll__k_poll_eventP.i.s32_t"></span><span class="target" id="db/d60/group__poll__apis_1ga3e8be74dbc9ce8bc019e4d8d2028bbb3"></span>int <code class="descname">k_poll</code><span class="sig-paren">(</span><em class="property">struct</em> k_poll_event *<em>events</em>, int <em>num_events</em>, s32_t <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv26k_pollP12k_poll_eventi5s32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for one or many of multiple poll events to occur. </p>
<p>This routine allows a thread to wait concurrently for one or many of multiple poll events to have occurred. Such events can be a kernel object being available, like a semaphore, or a poll signal event.</p>
<p>When an event notifies that a kernel object is available, the kernel object is not “given” to the thread calling k_poll(): it merely signals the fact that the object was available when the k_poll() call was in effect. Also, all threads trying to acquire an object the regular way, i.e. by pending on the object, have precedence over the thread polling on the object. This means that the polling thread will never get the poll event on an object until the object becomes available and its pend queue is empty. For this reason, the k_poll() call is more effective when the objects being polled only have one thread, the polling thread, trying to acquire them.</p>
<p>When k_poll() returns 0, the caller should loop on all the events that were passed to k_poll() and check the state field for the values that were expected and take the associated actions.</p>
<p>Before being reused for another call to k_poll(), the user has to reset the state field to K_POLL_STATE_NOT_READY.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">events</span></code>: An array of pointers to events to be polled for. </li>
<li><code class="docutils literal"><span class="pre">num_events</span></code>: The number of events in the array. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period for an event to be ready (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: One or more events are ready. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
<li><code class="docutils literal"><span class="pre">-EINTR</span></code>: Poller thread has been interrupted. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218k_poll_signal_initP13k_poll_signal">
<span id="k_poll_signal_init__k_poll_signalP"></span><span class="target" id="db/d60/group__poll__apis_1gaf139ff481674fd35dd74cd436e3375d2"></span>void <code class="descname">k_poll_signal_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#_CPPv213k_poll_signalP13k_poll_signali" title="k_poll_signal">k_poll_signal</a> *<em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv218k_poll_signal_initP13k_poll_signal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a poll signal object. </p>
<p>Ready a poll signal object to be signaled via k_poll_signal().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">signal</span></code>: A poll signal.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_poll_signalP13k_poll_signali">
<span id="k_poll_signal__k_poll_signalP.i"></span><span class="target" id="db/d60/group__poll__apis_1gaca6c327c239177e9069556ddad0ae6e9"></span>int <code class="descname">k_poll_signal</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#_CPPv213k_poll_signalP13k_poll_signali" title="k_poll_signal">k_poll_signal</a> *<em>signal</em>, int <em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv213k_poll_signalP13k_poll_signali" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal a poll signal object. </p>
<p>This routine makes ready a poll signal, which is basically a poll event of type K_POLL_TYPE_SIGNAL. If a thread was polling on that event, it will be made ready to run. A <em>result</em> value can be specified.</p>
<p>The poll signal contains a ‘signaled’ field that, when set by k_poll_signal(), stays set until the user sets it back to 0. It thus has to be reset by the user before being passed again to k_poll() or k_poll() will consider it being signaled, and will return immediately.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">signal</span></code>: A poll signal. </li>
<li><code class="docutils literal"><span class="pre">result</span></code>: The value to store in the result field of the signal.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: The signal was delivered successfully. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: The polling thread’s timeout is in the process of expiring. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223_handle_obj_poll_eventsP11sys_dlist_t5u32_t">
<span id="_handle_obj_poll_events__sys_dlist_tP.u32_t"></span><span class="target" id="db/d60/group__poll__apis_1ga52888e9eedad22a1af05dea9434e5608"></span>int <code class="descname">_handle_obj_poll_events</code><span class="sig-paren">(</span>sys_dlist_t *<em>events</em>, u32_t <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv223_handle_obj_poll_eventsP11sys_dlist_t5u32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<dl class="type">
<dt>
<span class="target" id="df/db4/unionk__poll__event_8____unnamed____"></span><em class="property">union </em></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt>
<span class="target" id="df/db4/unionk__poll__event_8____unnamed_____1abe8f80182e0c983916da7338c2c1c040"></span><code class="descname"></code></dt>
<dd></dd></dl>

<dl class="member">
<dt>
<span class="target" id="df/db4/unionk__poll__event_8____unnamed_____1a521345a9fb579f52117f27be6e0673ee"></span><code class="descname"></code></dt>
<dd></dd></dl>

<dl class="member">
<dt>
<span class="target" id="df/db4/unionk__poll__event_8____unnamed_____1abd9a2916f0e054a9361a98a97b8db5dc"></span><code class="descname"></code></dt>
<dd></dd></dl>

<dl class="member">
<dt>
<span class="target" id="df/db4/unionk__poll__event_8____unnamed_____1acf54937a2330ac17aa523bf7130911a3"></span><code class="descname"></code></dt>
<dd></dd></dl>

<dl class="member">
<dt>
<span class="target" id="df/db4/unionk__poll__event_8____unnamed_____1aa9d1cbf71942327e98b40cf5ef38a960"></span><code class="descname"></code></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interrupt-service-routines-isrs">
<h2><a class="toc-backref" href="#contents">Interrupt Service Routines (ISRs)</a><a class="headerlink" href="#interrupt-service-routines-isrs" title="Permalink to this headline">¶</a></h2>
<p>An interrupt service routine is a series of instructions that is
executed asynchronously in response to a hardware or software interrupt.
(See <a class="reference internal" href="../kernel/other/interrupts.html#interrupts-v2"><span class="std std-ref">Interrupts</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="da/d00/group__isr__apis"></span><em>group</em> <code class="descname">isr_apis</code></dt>
<dd><p>end defgroup thread_apis </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.IRQ_CONNECT">
<span class="target" id="da/d00/group__isr__apis_1ga131739d1faf501a15590053817aba984"></span><code class="descname">IRQ_CONNECT</code><span class="sig-paren">(</span>irq_p, priority_p, isr_p, isr_param_p, flags_p<span class="sig-paren">)</span><a class="headerlink" href="#c.IRQ_CONNECT" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an interrupt handler. </p>
<p>This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled before the interrupt handler begins servicing interrupts.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</dd>
<dt><strong>Return</strong></dt>
<dd>Interrupt vector assigned to this interrupt. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq_p</span></code>: IRQ line number. </li>
<li><code class="docutils literal"><span class="pre">priority_p</span></code>: Interrupt priority. </li>
<li><code class="docutils literal"><span class="pre">isr_p</span></code>: Address of interrupt service routine. </li>
<li><code class="docutils literal"><span class="pre">isr_param_p</span></code>: Parameter passed to interrupt service routine. </li>
<li><code class="docutils literal"><span class="pre">flags_p</span></code>: Architecture-specific IRQ configuration flags..</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.IRQ_DIRECT_CONNECT">
<span class="target" id="da/d00/group__isr__apis_1gac6c8746ac28da6ce02b24714f4144ff3"></span><code class="descname">IRQ_DIRECT_CONNECT</code><span class="sig-paren">(</span>irq_p, priority_p, isr_p, flags_p<span class="sig-paren">)</span><a class="headerlink" href="#c.IRQ_DIRECT_CONNECT" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a ‘direct’ interrupt handler. </p>
<p>This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled via irq_enable() before the interrupt handler begins servicing interrupts.</p>
<p>These ISRs are designed for performance-critical interrupt handling and do not go through common interrupt handling code. They must be implemented in such a way that it is safe to put them directly in the vector table. For ISRs written in C, The ISR_DIRECT_DECLARE() macro will do this automatically. For ISRs written in assembly it is entirely up to the developer to ensure that the right steps are taken.</p>
<p>This type of interrupt currently has a few limitations compared to normal Zephyr interrupts:<ul class="simple">
<li>No parameters are passed to the ISR.</li>
<li>No stack switch is done, the ISR will run on the interrupted context’s stack, unless the architecture automatically does the stack switch in HW.</li>
<li>Interrupt locking state is unchanged from how the HW sets it when the ISR runs. On arches that enter ISRs with interrupts locked, they will remain locked.</li>
<li>Scheduling decisions are now optional, controlled by the return value of ISRs implemented with the ISR_DIRECT_DECLARE() macro</li>
<li>The call into the OS to exit power management idle state is now optional. Normal interrupts always do this before the ISR is run, but when it runs is now controlled by the placement of a ISR_DIRECT_PM() macro, or omitted entirely.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</dd>
<dt><strong>Return</strong></dt>
<dd>Interrupt vector assigned to this interrupt. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq_p</span></code>: IRQ line number. </li>
<li><code class="docutils literal"><span class="pre">priority_p</span></code>: Interrupt priority. </li>
<li><code class="docutils literal"><span class="pre">isr_p</span></code>: Address of interrupt service routine. </li>
<li><code class="docutils literal"><span class="pre">flags_p</span></code>: Architecture-specific IRQ configuration flags.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ISR_DIRECT_HEADER">
<span class="target" id="da/d00/group__isr__apis_1ga1ab99dbeb50b228001e1fca808cbaeea"></span><code class="descname">ISR_DIRECT_HEADER</code><a class="headerlink" href="#c.ISR_DIRECT_HEADER" title="Permalink to this definition">¶</a></dt>
<dd><p>Common tasks before executing the body of an ISR. </p>
<p>This macro must be at the beginning of all direct interrupts and performs minimal architecture-specific tasks before the ISR itself can run. It takes no arguments and has no return value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ISR_DIRECT_FOOTER">
<span class="target" id="da/d00/group__isr__apis_1ga31581157c9dbacf935f0e6a8dd456335"></span><code class="descname">ISR_DIRECT_FOOTER</code><span class="sig-paren">(</span>check_reschedule<span class="sig-paren">)</span><a class="headerlink" href="#c.ISR_DIRECT_FOOTER" title="Permalink to this definition">¶</a></dt>
<dd><p>Common tasks before exiting the body of an ISR. </p>
<p>This macro must be at the end of all direct interrupts and performs minimal architecture-specific tasks like EOI. It has no return value.</p>
<p>In a normal interrupt, a check is done at end of interrupt to invoke _Swap() logic if the current thread is preemptible and there is another thread ready to run in the kernel’s ready queue cache. This is now optional and controlled by the check_reschedule argument. If unsure, set to nonzero. On systems that do stack switching and nested interrupt tracking in software, _Swap() should only be called if this was a non-nested interrupt.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">check_reschedule</span></code>: If nonzero, additionally invoke scheduling logic </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ISR_DIRECT_PM">
<span class="target" id="da/d00/group__isr__apis_1ga3c1327551dfca7818975e3fbf1470227"></span><code class="descname">ISR_DIRECT_PM</code><a class="headerlink" href="#c.ISR_DIRECT_PM" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform power management idle exit logic. </p>
<p>This macro may optionally be invoked somewhere in between IRQ_DIRECT_HEADER() and IRQ_DIRECT_FOOTER() invocations. It performs tasks necessary to exit power management idle state. It takes no parameters and returns no arguments. It may be omitted, but be careful! </p>
</dd></dl>

<dl class="macro">
<dt id="c.ISR_DIRECT_DECLARE">
<span class="target" id="da/d00/group__isr__apis_1gaf86866cd07fd37f381d98866f8874ebf"></span><code class="descname">ISR_DIRECT_DECLARE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span><a class="headerlink" href="#c.ISR_DIRECT_DECLARE" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro to declare a direct interrupt service routine. </p>
<p>This will declare the function in a proper way and automatically include the ISR_DIRECT_FOOTER() and ISR_DIRECT_HEADER() macros. The function should return nonzero status if a scheduling decision should potentially be made. See ISR_DIRECT_FOOTER() for more details on the scheduling decision.</p>
<p>For architectures that support ‘regular’ and ‘fast’ interrupt types, where these interrupt types require different assembly language handling of registers by the ISR, this will always generate code for the ‘fast’ interrupt type.</p>
<p>Example usage:</p>
<p>ISR_DIRECT_DECLARE(my_isr) { bool done = do_stuff(); ISR_DIRECT_PM(); &lt; done after do_stuff() due to latency concerns if (!done) { return 0; &lt; Don’t bother checking if we have to _Swap() } k_sem_give(some_sem); return 1; }</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: symbol name of the ISR </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_lock">
<span class="target" id="da/d00/group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"></span><code class="descname">irq_lock</code><a class="headerlink" href="#c.irq_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock interrupts. </p>
<p>This routine disables all interrupts on the CPU. It returns an unsigned integer “lock-out key”, which is an architecture-dependent indicator of whether interrupts were locked prior to the call. The lock-out key must be passed to irq_unlock() to re-enable interrupts.</p>
<p>This routine can be called recursively, as long as the caller keeps track of each lock-out key that is generated. Interrupts are re-enabled by passing each of the keys to irq_unlock() in the reverse order they were acquired. (That is, each call to irq_lock() must be balanced by a corresponding call to irq_unlock().)</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This routine can be called by ISRs or by threads. If it is called by a thread, the interrupt lock is thread-specific; this means that interrupts remain disabled only while the thread is running. If the thread performs an operation that allows another thread to run (for example, giving a semaphore or sleeping for N milliseconds), the interrupt lock no longer applies and interrupts may be re-enabled while other processing occurs. When the thread once again becomes the current thread, the kernel re-establishes its interrupt lock; this ensures the thread won’t be interrupted until it has explicitly released the interrupt lock it established.</dd>
<dt><strong>Warning</strong></dt>
<dd>The lock-out key should never be used to manually re-enable interrupts or to inspect or manipulate the contents of the CPU’s interrupt bits.</dd>
<dt><strong>Return</strong></dt>
<dd>Lock-out key. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_unlock">
<span class="target" id="da/d00/group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"></span><code class="descname">irq_unlock</code><span class="sig-paren">(</span>key<span class="sig-paren">)</span><a class="headerlink" href="#c.irq_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock interrupts. </p>
<p>This routine reverses the effect of a previous call to irq_lock() using the associated lock-out key. The caller must call the routine once for each time it called irq_lock(), supplying the keys in the reverse order they were acquired, before interrupts are enabled.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">key</span></code>: Lock-out key generated by irq_lock().</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_enable">
<span class="target" id="da/d00/group__isr__apis_1ga7ea700ee31e4ff036c997a554dbedfeb"></span><code class="descname">irq_enable</code><span class="sig-paren">(</span>irq<span class="sig-paren">)</span><a class="headerlink" href="#c.irq_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable an IRQ. </p>
<p>This routine enables interrupts from source <em>irq</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq</span></code>: IRQ line.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_disable">
<span class="target" id="da/d00/group__isr__apis_1ga82c3a15d812f58e0f6525f358d031e6d"></span><code class="descname">irq_disable</code><span class="sig-paren">(</span>irq<span class="sig-paren">)</span><a class="headerlink" href="#c.irq_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable an IRQ. </p>
<p>This routine disables interrupts from source <em>irq</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq</span></code>: IRQ line.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_is_enabled">
<span class="target" id="da/d00/group__isr__apis_1ga71fef3867ba9818cf0a5baf8410a6354"></span><code class="descname">irq_is_enabled</code><span class="sig-paren">(</span>irq<span class="sig-paren">)</span><a class="headerlink" href="#c.irq_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Get IRQ enable state. </p>
<p>This routine indicates if interrupts from source <em>irq</em> are enabled.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>interrupt enable state, true or false </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq</span></code>: IRQ line.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv211k_is_in_isrv">
<span id="k_is_in_isr__void"></span><span class="target" id="da/d00/group__isr__apis_1ga7d3be1c531238fda9822430976f2d6b4"></span>int <code class="descname">k_is_in_isr</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211k_is_in_isrv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if code is running at interrupt level. </p>
<p>This routine allows the caller to customize its actions, depending on whether it is a thread or an ISR.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>0 if invoked by a thread. </dd>
<dt><strong>Return</strong></dt>
<dd>Non-zero if invoked by an ISR. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_is_preempt_threadv">
<span id="k_is_preempt_thread__void"></span><span class="target" id="da/d00/group__isr__apis_1ga91e1cf0dc7fc93a3214cadb74ed86666"></span>int <code class="descname">k_is_preempt_thread</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv219k_is_preempt_threadv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if code is running in a preemptible thread. </p>
<p>This routine allows the caller to customize its actions, depending on whether it can be preempted by another thread. The routine returns a ‘true’ value if all of the following conditions are met:</p>
<p><ul class="simple">
<li>The code is running in a thread, not at ISR.</li>
<li>The thread’s priority is in the preemptible range.</li>
<li>The thread has not locked the scheduler.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>0 if invoked by an ISR or by a cooperative thread. </dd>
<dt><strong>Return</strong></dt>
<dd>Non-zero if invoked by a preemptible thread. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="atomic-services">
<h2><a class="toc-backref" href="#contents">Atomic Services</a><a class="headerlink" href="#atomic-services" title="Permalink to this headline">¶</a></h2>
<p>The atomic services enable multiple threads and ISRs to read and modify
32-bit variables in an uninterruptible manner.
(See <a class="reference internal" href="../kernel/other/atomic.html#atomic-v2"><span class="std std-ref">Atomic Services</span></a>.)</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">All atomic services APIs can be used by both threads and ISRs.</p>
</div>
<dl class="group">
<dt>
<span class="target" id="dc/d38/group__atomic__apis"></span><em>group</em> <code class="descname">atomic_apis</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.ATOMIC_INIT">
<span class="target" id="dc/d38/group__atomic__apis_1gaadfbba86627ee7eeb07e04f712550f73"></span><code class="descname">ATOMIC_INIT</code><span class="sig-paren">(</span>i<span class="sig-paren">)</span><a class="headerlink" href="#c.ATOMIC_INIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an atomic variable. </p>
<p>This macro can be used to initialize an atomic variable. For example, <div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">atomic_t</span> <span class="n">my_var</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">75</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">i</span></code>: Value to assign to atomic variable. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ATOMIC_DEFINE">
<span class="target" id="dc/d38/group__atomic__apis_1ga249c575db9764486197709b327f7370e"></span><code class="descname">ATOMIC_DEFINE</code><span class="sig-paren">(</span>name, num_bits<span class="sig-paren">)</span><a class="headerlink" href="#c.ATOMIC_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Define an array of atomic variables. </p>
<p>This macro defines an array of atomic variables containing at least <em>num_bits</em> bits.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If used from file scope, the bits of the array are initialized to zero; if used from within a function, the bits are left uninitialized.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of array of atomic variables. </li>
<li><code class="docutils literal"><span class="pre">num_bits</span></code>: Number of bits needed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv210atomic_casP8atomic_t12atomic_val_t12atomic_val_t">
<span id="atomic_cas__atomic_tP.atomic_val_t.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga1f735954844cb1a70ff23ba628899f3e"></span>int <code class="descname">atomic_cas</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>old_value</em>, atomic_val_t <em>new_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_casP8atomic_t12atomic_val_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic compare-and-set. </p>
<p>This routine performs an atomic compare-and-set on <em>target</em>. If the current value of <em>target</em> equals <em>old_value</em>, <em>target</em> is set to <em>new_value</em>. If the current value of <em>target</em> does not equal <em>old_value</em>, <em>target</em> is left unchanged.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if <em>new_value</em> is written, 0 otherwise. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">old_value</span></code>: Original value to compare against. </li>
<li><code class="docutils literal"><span class="pre">new_value</span></code>: New value to store. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_addP8atomic_t12atomic_val_t">
<span id="atomic_add__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga518c07595daaca29a9e53071ed59c9c0"></span>atomic_val_t <code class="descname">atomic_add</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_addP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic addition. </p>
<p>This routine performs an atomic addition on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to add.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_subP8atomic_t12atomic_val_t">
<span id="atomic_sub__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga84ab58fd0a6dbbf1bf675722b5900bd7"></span>atomic_val_t <code class="descname">atomic_sub</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_subP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic subtraction. </p>
<p>This routine performs an atomic subtraction on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to subtract.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_incP8atomic_t">
<span id="atomic_inc__atomic_tP"></span><span class="target" id="dc/d38/group__atomic__apis_1gaae47a9cbe5a6534967b417f602b37ac2"></span>atomic_val_t <code class="descname">atomic_inc</code><span class="sig-paren">(</span>atomic_t *<em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_incP8atomic_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic increment. </p>
<p>This routine performs an atomic increment by 1 on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_decP8atomic_t">
<span id="atomic_dec__atomic_tP"></span><span class="target" id="dc/d38/group__atomic__apis_1gac260f0efbd970717eae4ac3bb493a0c4"></span>atomic_val_t <code class="descname">atomic_dec</code><span class="sig-paren">(</span>atomic_t *<em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_decP8atomic_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic decrement. </p>
<p>This routine performs an atomic decrement by 1 on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_getPK8atomic_t">
<span id="atomic_get__atomic_tCP"></span><span class="target" id="dc/d38/group__atomic__apis_1ga33bb426a17535bd1022895a7e44b32fa"></span>atomic_val_t <code class="descname">atomic_get</code><span class="sig-paren">(</span><em class="property">const</em> atomic_t *<em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_getPK8atomic_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic get. </p>
<p>This routine performs an atomic read on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_setP8atomic_t12atomic_val_t">
<span id="atomic_set__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga5f0555245d8932c2e7f7e94575e1a095"></span>atomic_val_t <code class="descname">atomic_set</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_setP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic get-and-set. </p>
<p>This routine atomically sets <em>target</em> to <em>value</em> and returns the previous value of <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to write to <em>target</em>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212atomic_clearP8atomic_t">
<span id="atomic_clear__atomic_tP"></span><span class="target" id="dc/d38/group__atomic__apis_1ga879b5f540c25fd09f1b84563e3dc8a91"></span>atomic_val_t <code class="descname">atomic_clear</code><span class="sig-paren">(</span>atomic_t *<em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212atomic_clearP8atomic_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic clear. </p>
<p>This routine atomically sets <em>target</em> to zero and returns its previous value. (Hence, it is equivalent to atomic_set(target, 0).)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29atomic_orP8atomic_t12atomic_val_t">
<span id="atomic_or__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga1564a44a260e7d0d02e30ae045a99764"></span>atomic_val_t <code class="descname">atomic_or</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv29atomic_orP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic bitwise inclusive OR. </p>
<p>This routine atomically sets <em>target</em> to the bitwise inclusive OR of <em>target</em> and <em>value</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to OR.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_xorP8atomic_t12atomic_val_t">
<span id="atomic_xor__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga18592bcf38d667fb9b428f81ea691bd4"></span>atomic_val_t <code class="descname">atomic_xor</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_xorP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic bitwise exclusive OR (XOR). </p>
<p>This routine atomically sets <em>target</em> to the bitwise exclusive OR (XOR) of <em>target</em> and <em>value</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to XOR</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_andP8atomic_t12atomic_val_t">
<span id="atomic_and__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga4bc1f6a6f5d98eef742b4541d235811d"></span>atomic_val_t <code class="descname">atomic_and</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv210atomic_andP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic bitwise AND. </p>
<p>This routine atomically sets <em>target</em> to the bitwise AND of <em>target</em> and <em>value</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to AND.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211atomic_nandP8atomic_t12atomic_val_t">
<span id="atomic_nand__atomic_tP.atomic_val_t"></span><span class="target" id="dc/d38/group__atomic__apis_1ga3e954286e40de73e45598a00a0a2b864"></span>atomic_val_t <code class="descname">atomic_nand</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv211atomic_nandP8atomic_t12atomic_val_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic bitwise NAND. </p>
<p>This routine atomically sets <em>target</em> to the bitwise NAND of <em>target</em> and <em>value</em>. (This operation is equivalent to target = ~(target &amp; value).)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to NAND.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215atomic_test_bitPK8atomic_ti">
<span id="atomic_test_bit__atomic_tCP.i"></span><span class="target" id="dc/d38/group__atomic__apis_1ga08971aaa4161b6271fb258c816b831f6"></span><em class="property">static</em> int <code class="descname">atomic_test_bit</code><span class="sig-paren">(</span><em class="property">const</em> atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215atomic_test_bitPK8atomic_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically test a bit. </p>
<p>This routine tests whether bit number <em>bit</em> of <em>target</em> is set or not. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the bit was set, 0 if it wasn’t. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225atomic_test_and_clear_bitP8atomic_ti">
<span id="atomic_test_and_clear_bit__atomic_tP.i"></span><span class="target" id="dc/d38/group__atomic__apis_1gad1f355a1833ffb2caba13115975c2cad"></span><em class="property">static</em> int <code class="descname">atomic_test_and_clear_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv225atomic_test_and_clear_bitP8atomic_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically test and clear a bit. </p>
<p>Atomically clear bit number <em>bit</em> of <em>target</em> and return its old value. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the bit was set, 0 if it wasn’t. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223atomic_test_and_set_bitP8atomic_ti">
<span id="atomic_test_and_set_bit__atomic_tP.i"></span><span class="target" id="dc/d38/group__atomic__apis_1ga5a26c1dc6c768061a16ff84c3f45e730"></span><em class="property">static</em> int <code class="descname">atomic_test_and_set_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv223atomic_test_and_set_bitP8atomic_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically set a bit. </p>
<p>Atomically set bit number <em>bit</em> of <em>target</em> and return its old value. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the bit was set, 0 if it wasn’t. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216atomic_clear_bitP8atomic_ti">
<span id="atomic_clear_bit__atomic_tP.i"></span><span class="target" id="dc/d38/group__atomic__apis_1ga1c1693d524c49d11fd32b323a39d718e"></span><em class="property">static</em> void <code class="descname">atomic_clear_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216atomic_clear_bitP8atomic_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically clear a bit. </p>
<p>Atomically clear bit number <em>bit</em> of <em>target</em>. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214atomic_set_bitP8atomic_ti">
<span id="atomic_set_bit__atomic_tP.i"></span><span class="target" id="dc/d38/group__atomic__apis_1ga17a3961ba7610ad6e595e602f70344a0"></span><em class="property">static</em> void <code class="descname">atomic_set_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214atomic_set_bitP8atomic_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically set a bit. </p>
<p>Atomically set bit number <em>bit</em> of <em>target</em>. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="profiling">
<h2><a class="toc-backref" href="#contents">Profiling</a><a class="headerlink" href="#profiling" title="Permalink to this headline">¶</a></h2>
<dl class="group">
<dt>
<span class="target" id="dc/d96/group__profiling__apis"></span><em>group</em> <code class="descname">profiling_apis</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv221k_call_stacks_analyzev">
<span id="k_call_stacks_analyze__void"></span><span class="target" id="dc/d96/group__profiling__apis_1gaedff93cfef631a5981cebd9c1e127a3e"></span>void <code class="descname">k_call_stacks_analyze</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221k_call_stacks_analyzev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Analyze the main, idle, interrupt and system workqueue call stacks. </p>
<p>This routine calls STACK_ANALYZE on the 4 call stacks declared and maintained by the kernel. The sizes of those 4 call stacks are defined by:</p>
<p>CONFIG_MAIN_STACK_SIZE CONFIG_IDLE_STACK_SIZE CONFIG_ISR_STACK_SIZE CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>CONFIG_INIT_STACKS and CONFIG_PRINTK must be set for this function to produce output.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="floating-point-services">
<h2><a class="toc-backref" href="#contents">Floating Point Services</a><a class="headerlink" href="#floating-point-services" title="Permalink to this headline">¶</a></h2>
<p>The floating point services enable threads to use a board’s floating point
registers.
(See <a class="reference internal" href="../kernel/other/float.html#float-v2"><span class="std std-ref">Floating Point Services</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="d6/dd7/group__float__apis"></span><em>group</em> <code class="descname">float_apis</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv27k_tid_t">
<span id="k_tid_t"></span><span class="target" id="d6/dd7/group__float__apis_1ga6379f5a1f19ffbc262a6877c4f6e3647"></span><em class="property">typedef </em><em class="property">struct</em> k_thread *<code class="descname">k_tid_t</code><a class="headerlink" href="#_CPPv27k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv214k_float_enable7k_tid_tj">
<span id="k_float_enable__k_tid_t.unsigned-i"></span><span class="target" id="d6/dd7/group__float__apis_1gaa13fb58f5f8eaba79aa3fb7d59514a49"></span>void <code class="descname">k_float_enable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em>, unsigned int <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214k_float_enable7k_tid_tj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable preservation of floating point context information. </p>
<p>This routine informs the kernel that the specified thread (which may be the current thread) will be using the floating point registers. The <em>options</em> parameter indicates which floating point register sets will be used by the specified thread:</p>
<p>a) K_FP_REGS indicates x87 FPU and MMX registers only b) K_SSE_REGS indicates SSE registers (and also x87 FPU and MMX registers)</p>
<p>Invoking this routine initializes the thread’s floating point context info to that of an FPU that has been reset. The next time the thread is scheduled by _Swap() it will either inherit an FPU that is guaranteed to be in a “sane” state (if the most recent user of the FPU was cooperatively swapped out) or the thread’s own floating point context will be loaded (if the most recent user of the FPU was preempted, or if this thread is the first user of the FPU). Thereafter, the kernel will protect the thread’s FP context so that it is not altered during a preemptive context switch.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This routine should only be used to enable floating point support for a thread that does not currently have such support enabled already.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Registers to be preserved (K_FP_REGS or K_SSE_REGS).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_float_disable7k_tid_t">
<span id="k_float_disable__k_tid_t"></span><span class="target" id="d6/dd7/group__float__apis_1ga74bfced0c73c26293d3b67083892406e"></span>void <code class="descname">k_float_disable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv215k_float_disable7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable preservation of floating point context information. </p>
<p>This routine informs the kernel that the specified thread (which may be the current thread) will no longer be using the floating point registers.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This routine should only be used to disable floating point support for a thread that currently has such support enabled.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="ring-buffers">
<h2><a class="toc-backref" href="#contents">Ring Buffers</a><a class="headerlink" href="#ring-buffers" title="Permalink to this headline">¶</a></h2>
<p>Ring buffers enable simple first in, first out (FIFO) queuing
of variable-size data items.
(See <a class="reference internal" href="../kernel/other/ring_buffers.html#ring-buffers-v2"><span class="std std-ref">Ring Buffers</span></a>.)</p>
<dl class="function">
<dt id="_CPPv217sys_ring_buf_initP8ring_buf5u32_tP5u32_t">
<span id="sys_ring_buf_init__ring_bufP.u32_t.u32_tP"></span><span class="target" id="d4/dc5/group__ring__buffer__apis_1ga8947e8b773460a68187f9de3732fa4cf"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">sys_ring_buf_init</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em>, u32_t <em>size</em>, u32_t *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217sys_ring_buf_initP8ring_buf5u32_tP5u32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a ring buffer. </p>
<p>This routine initializes a ring buffer, prior to its first use. It is only used for ring buffers not defined using SYS_RING_BUF_DECLARE_POW2 or SYS_RING_BUF_DECLARE_SIZE.</p>
<p>Setting <em>size</em> to a power of 2 establishes a high performance ring buffer that doesn’t require the use of modulo arithmetic operations to maintain itself.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Ring buffer size (in 32-bit words). </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Ring buffer data area (typically u32_t data[size]). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221sys_ring_buf_is_emptyP8ring_buf">
<span id="sys_ring_buf_is_empty__ring_bufP"></span><span class="target" id="d4/dc5/group__ring__buffer__apis_1ga1322214c33835c164f6c83088ccb5426"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sys_ring_buf_is_empty</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv221sys_ring_buf_is_emptyP8ring_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if a ring buffer is empty. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the ring buffer is empty, or 0 if not. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222sys_ring_buf_space_getP8ring_buf">
<span id="sys_ring_buf_space_get__ring_bufP"></span><span class="target" id="d4/dc5/group__ring__buffer__apis_1gac86de55625f8834a94a3b9458ada225e"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sys_ring_buf_space_get</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv222sys_ring_buf_space_getP8ring_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine free space in a ring buffer. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Ring buffer free space (in 32-bit words). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216sys_ring_buf_putP8ring_buf5u16_t4u8_tP5u32_t4u8_t">
<span id="sys_ring_buf_put__ring_bufP.u16_t.u8_t.u32_tP.u8_t"></span><span class="target" id="d4/dc5/group__ring__buffer__apis_1ga729c8cce8449ae973a6376b04f0a182d"></span>int <code class="descclassname"></code><code class="descname">sys_ring_buf_put</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em>, u16_t <em>type</em>, u8_t <em>value</em>, u32_t *<em>data</em>, u8_t <em>size32</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216sys_ring_buf_putP8ring_buf5u16_t4u8_tP5u32_t4u8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a data item to a ring buffer. </p>
<p>This routine writes a data item to ring buffer <em>buf</em>. The data item is an array of 32-bit words (from zero to 1020 bytes in length), coupled with a 16-bit type identifier and an 8-bit integer value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Use cases involving multiple writers to the ring buffer must prevent concurrent write operations, either by preventing all writers from being preempted or by using a mutex to govern writes to the ring buffer.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer. </li>
<li><code class="docutils literal"><span class="pre">type</span></code>: Data item’s type identifier (application specific). </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Data item’s integer value (application specific). </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of data item. </li>
<li><code class="docutils literal"><span class="pre">size32</span></code>: Data item size (number of 32-bit words).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Data item was written. </li>
<li><code class="docutils literal"><span class="pre">-EMSGSIZE</span></code>: Ring buffer has insufficient free space. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216sys_ring_buf_getP8ring_bufP5u16_tP4u8_tP5u32_tP4u8_t">
<span id="sys_ring_buf_get__ring_bufP.u16_tP.u8_tP.u32_tP.u8_tP"></span><span class="target" id="d4/dc5/group__ring__buffer__apis_1gab05e8197908d0d3bf431a9ccc1e7bccb"></span>int <code class="descclassname"></code><code class="descname">sys_ring_buf_get</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em>, u16_t *<em>type</em>, u8_t *<em>value</em>, u32_t *<em>data</em>, u8_t *<em>size32</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216sys_ring_buf_getP8ring_bufP5u16_tP4u8_tP5u32_tP4u8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read a data item from a ring buffer. </p>
<p>This routine reads a data item from ring buffer <em>buf</em>. The data item is an array of 32-bit words (up to 1020 bytes in length), coupled with a 16-bit type identifier and an 8-bit integer value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Use cases involving multiple reads of the ring buffer must prevent concurrent read operations, either by preventing all readers from being preempted or by using a mutex to govern reads to the ring buffer.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer. </li>
<li><code class="docutils literal"><span class="pre">type</span></code>: Area to store the data item’s type identifier. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Area to store the data item’s integer value. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Area to store the data item. </li>
<li><code class="docutils literal"><span class="pre">size32</span></code>: Size of the data item storage area (number of 32-bit chunks).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Data item was fetched; <em>size32</em> now contains the number of 32-bit words read into data area <em>data</em>. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Ring buffer is empty. </li>
<li><code class="docutils literal"><span class="pre">-EMSGSIZE</span></code>: Data area <em>data</em> is too small; <em>size32</em> now contains the number of 32-bit words needed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SYS_RING_BUF_DECLARE_POW2">
<span class="target" id="d4/dc5/group__ring__buffer__apis_1ga3c62d9daa70ece8f00c9e7c607ac5f29"></span><code class="descname">SYS_RING_BUF_DECLARE_POW2</code><span class="sig-paren">(</span>name, pow<span class="sig-paren">)</span><a class="headerlink" href="#c.SYS_RING_BUF_DECLARE_POW2" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a high performance ring buffer. </p>
<p>This macro establishes a ring buffer whose size must be a power of 2; that is, the ring buffer contains 2^pow 32-bit words, where <em>pow</em> is the specified ring buffer size exponent. A high performance ring buffer doesn’t require the use of modulo arithmetic operations to maintain itself.</p>
<p>The ring buffer can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">ring_buf</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the ring buffer. </li>
<li><code class="docutils literal"><span class="pre">pow</span></code>: Ring buffer size exponent. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SYS_RING_BUF_DECLARE_SIZE">
<span class="target" id="d4/dc5/group__ring__buffer__apis_1ga4f82802fe81fd71ed801c5e4eaab926a"></span><code class="descname">SYS_RING_BUF_DECLARE_SIZE</code><span class="sig-paren">(</span>name, size32<span class="sig-paren">)</span><a class="headerlink" href="#c.SYS_RING_BUF_DECLARE_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>Statically define and initialize a standard ring buffer. </p>
<p>This macro establishes a ring buffer of an arbitrary size. A standard ring buffer uses modulo arithmetic operations to maintain itself.</p>
<p>The ring buffer can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">ring_buf</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the ring buffer. </li>
<li><code class="docutils literal"><span class="pre">size32</span></code>: Size of ring buffer (in 32-bit words). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="memory-domain">
<h2><a class="toc-backref" href="#contents">Memory Domain</a><a class="headerlink" href="#memory-domain" title="Permalink to this headline">¶</a></h2>
<p>A memory domain contains some number of memory partitions. Threads can
specify the range and attribute (access permission) for memory partitions
in a memory domain. Threads in the same memory domain have the
same access permissions to the memory partitions belong to the
memory domain.
(See <a class="reference internal" href="../kernel/usermode/memory_domain.html#memory-domain"><span class="std std-ref">Memory Domain</span></a>.)</p>
<dl class="group">
<dt>
<span class="target" id="dc/dcc/group__mem__domain__apis"></span><em>group</em> <code class="descname">mem_domain_apis</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.MEM_PARTITION_ENTRY">
<span class="target" id="dc/dcc/group__mem__domain__apis_1gaa4ecf3096802e341d0ec88e4413794d7"></span><code class="descname">MEM_PARTITION_ENTRY</code><span class="sig-paren">(</span>_start, _size, _attr<span class="sig-paren">)</span><a class="headerlink" href="#c.MEM_PARTITION_ENTRY" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to declare a memory partition entry. </p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MEM_PARTITION_DEFINE">
<span class="target" id="dc/dcc/group__mem__domain__apis_1ga4360fd595cb3fe3a10b58c12ae2b7ece"></span><code class="descname">K_MEM_PARTITION_DEFINE</code><span class="sig-paren">(</span>name, start, size, attr<span class="sig-paren">)</span><a class="headerlink" href="#c.K_MEM_PARTITION_DEFINE" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to declare a memory partition. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv217k_mem_domain_initP12k_mem_domain5u32_tA_P15k_mem_partition">
<span id="k_mem_domain_init__k_mem_domainP.u32_t.k_mem_partitionPA"></span><span class="target" id="dc/dcc/group__mem__domain__apis_1ga5dd7e5f44b6e8185dbfade546f300d36"></span>void <code class="descname">k_mem_domain_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_domain *<em>domain</em>, u32_t <em>num_parts</em>, <em class="property">struct</em> k_mem_partition *<em>parts</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv217k_mem_domain_initP12k_mem_domain5u32_tA_P15k_mem_partition" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a memory domain. </p>
<p>Initialize a memory domain with given name and memory partitions.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">domain</span></code>: The memory domain to be initialized. </li>
<li><code class="docutils literal"><span class="pre">num_parts</span></code>: The number of array items of “parts” parameter. </li>
<li><code class="docutils literal"><span class="pre">parts</span></code>: An array of pointers to the memory partitions. Can be NULL if num_parts is zero. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220k_mem_domain_destroyP12k_mem_domain">
<span id="k_mem_domain_destroy__k_mem_domainP"></span><span class="target" id="dc/dcc/group__mem__domain__apis_1gad62103f1ffba7d35b54eabdf7560ba2a"></span>void <code class="descname">k_mem_domain_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_domain *<em>domain</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv220k_mem_domain_destroyP12k_mem_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a memory domain. </p>
<p>Destroy a memory domain.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">domain</span></code>: The memory domain to be destroyed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv226k_mem_domain_add_partitionP12k_mem_domainP15k_mem_partition">
<span id="k_mem_domain_add_partition__k_mem_domainP.k_mem_partitionP"></span><span class="target" id="dc/dcc/group__mem__domain__apis_1ga282053074ce42db373f429dc46485ab9"></span>void <code class="descname">k_mem_domain_add_partition</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_domain *<em>domain</em>, <em class="property">struct</em> k_mem_partition *<em>part</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv226k_mem_domain_add_partitionP12k_mem_domainP15k_mem_partition" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a memory partition into a memory domain. </p>
<p>Add a memory partition into a memory domain.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">domain</span></code>: The memory domain to be added a memory partition. </li>
<li><code class="docutils literal"><span class="pre">part</span></code>: The memory partition to be added </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv229k_mem_domain_remove_partitionP12k_mem_domainP15k_mem_partition">
<span id="k_mem_domain_remove_partition__k_mem_domainP.k_mem_partitionP"></span><span class="target" id="dc/dcc/group__mem__domain__apis_1gab93bcab0673b089a1b7e302de5b38e52"></span>void <code class="descname">k_mem_domain_remove_partition</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_domain *<em>domain</em>, <em class="property">struct</em> k_mem_partition *<em>part</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv229k_mem_domain_remove_partitionP12k_mem_domainP15k_mem_partition" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a memory partition from a memory domain. </p>
<p>Remove a memory partition from a memory domain.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">domain</span></code>: The memory domain to be removed a memory partition. </li>
<li><code class="docutils literal"><span class="pre">part</span></code>: The memory partition to be removed </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223k_mem_domain_add_threadP12k_mem_domain7k_tid_t">
<span id="k_mem_domain_add_thread__k_mem_domainP.k_tid_t"></span><span class="target" id="dc/dcc/group__mem__domain__apis_1ga4eeb51f8dc999fcc98d80415a8f7e4e4"></span>void <code class="descname">k_mem_domain_add_thread</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_domain *<em>domain</em>, <a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv223k_mem_domain_add_threadP12k_mem_domain7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a thread into a memory domain. </p>
<p>Add a thread into a memory domain.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">domain</span></code>: The memory domain that the thread is going to be added into. </li>
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread going to be added into the memory domain. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv226k_mem_domain_remove_thread7k_tid_t">
<span id="k_mem_domain_remove_thread__k_tid_t"></span><span class="target" id="dc/dcc/group__mem__domain__apis_1ga29a3908d25c5759011c3ad40bb0e5485"></span>void <code class="descname">k_mem_domain_remove_thread</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv27k_tid_t" title="k_tid_t">k_tid_t</a> <em>thread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv226k_mem_domain_remove_thread7k_tid_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a thread from its memory domain. </p>
<p>Remove a thread from its memory domain.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread going to be removed from its memory domain. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


                </div>
              </div>
              <!-- 
  <div class="rst-footer-buttons row" role="navigation" aria-label="footer navigation">
    
      <a href="device.html" class="btn btn-neutral float-right" title="Device Driver Interface" accesskey="n">
        Next <span class="fa fa-arrow-circle-right"></span>
      </a>
    
    
      <a href="api.html" class="btn btn-neutral" title="API Documentation" accesskey="p">
        <span class="fa fa-arrow-circle-left"></span> Previous
      </a>
    
  </div>
  for ZEP-463 remove the prev/next links -->
            </div>
            <!-- ENDS #content SECTION -->
          </section>
          <!-- ENDS .content -->
        </div>
        <!-- ENDS .main-container -->
      </div>
      <!-- ENDS #main -->
      <footer id="footer">
  <div class="container">
    <div class="block block-menu block-odd first block" data-bid="menu-footer-menu">
      <h3 class="title">Footer Menu</h3>
      <ul class="menu">
        <li class="leaf google- mid-2404">
          <a href="https://plus.google.com/+ZephyrProject" class="google-plus"><span>Google+</span></a>
        </li>
        <li class="leaf twitter mid-2405">
          <a href="https://twitter.com/zephyriot" class="twitter"><span>Twitter</span></a>
        </li>
        <li class="last leaf email mid-2406">
          <a href="mailto:info@zephyrproject.org" class="email"><span>Email</span></a>
        </li>
      </ul>
    </div>
    <div class="block block-block block-even block" data-bid="block-4">
      <p>
        Zephyr Project © 2018 is a Linux Foundation Project. All Rights Reserved.
      </p>
      <p>
        <a href="https://linuxfoundation.org" target="_blank">Linux Foundation</a> is a registered trademark of The Linux Foundation. Linux is a registered <a href="https://www.linuxfoundation.org/about/linux-foundation-trademark-usage-guidelines" target="_blank">trademark</a> of Linus Torvalds.
      </p>
      <p>
        Please see our <a href="https://www.linuxfoundation.org/privacy" target="_blank">privacy policy</a> and <a href="https://www.linuxfoundation.org/terms" target="_blank">terms of use</a>
      </p>
    </div>
  </div>
</footer>
    </div>
    <!-- ENDS #page -->

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.10.99',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/js/main.js"></script>
      <script type="text/javascript" src="../_static/js/app.js"></script>
      <script type="text/javascript" src="../_static/js/affix.js"></script>

   

  </body>
</html>